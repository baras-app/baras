---
phase: 03-core-error-handling
plan: 03
type: execute
wave: 2
depends_on: ["01", "02"]
files_modified:
  - core/src/context/config.rs
  - core/src/combat_log/reader.rs
  - core/src/combat_log/error.rs
autonomous: true

must_haves:
  truths:
    - "config.rs save() returns Result instead of panicking"
    - "reader.rs uses Result for session date access"
    - "Zero expect() calls remain in core/src production code"
  artifacts:
    - path: "core/src/context/config.rs"
      provides: "Fallible save with Result return"
      contains: "fn save(self) -> Result<(), ConfigError>"
    - path: "core/src/combat_log/reader.rs"
      provides: "Session date access via Result"
      contains: "SessionDateMissing"
    - path: "core/src/combat_log/error.rs"
      provides: "SessionDateMissing error variant"
      contains: "SessionDateMissing"
  key_links:
    - from: "core/src/context/config.rs"
      to: "context/error.rs ConfigError"
      via: "Result return type"
      pattern: "Result<\\(\\), ConfigError>"
    - from: "core/src/combat_log/reader.rs"
      to: "combat_log/error.rs ReaderError"
      via: "SessionDateMissing variant"
      pattern: "ReaderError::SessionDateMissing"
---

<objective>
Convert public API expect() calls to proper Result returns with error propagation.

Purpose: The remaining 2 expect() calls are in public-facing functions (config save, reader session state). Converting these to Result returns enables callers to handle errors gracefully rather than crashing.

Output: config.rs save() returns Result, reader.rs tail_lines() propagates ReaderError::SessionDateMissing.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-core-error-handling/03-RESEARCH.md

@core/src/context/config.rs
@core/src/context/error.rs
@core/src/combat_log/reader.rs
@core/src/combat_log/error.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert config.rs save() to return Result</name>
  <files>core/src/context/config.rs, core/src/context/error.rs</files>
  <action>
**context/config.rs line 68-69:**

Current trait and implementation:
```rust
// In AppConfigExt trait
fn save(self);

// In impl
fn save(self) {
    confy::store("baras", "config", self).expect("Failed to save configuration");
}
```

ConfigError::Save already exists in context/error.rs (created in Phase 2).

1. Change trait signature to return Result:
```rust
fn save(self) -> Result<(), ConfigError>;
```

2. Update implementation:
```rust
fn save(self) -> Result<(), ConfigError> {
    confy::store("baras", "config", self).map_err(ConfigError::Save)?;
    tracing::debug!("Configuration saved successfully");
    Ok(())
}
```

3. Add import at top of config.rs if not present:
```rust
use super::error::ConfigError;
```

4. Find all call sites of `.save()` in the codebase and update them to handle the Result. Common patterns:
   - If in a function that can propagate: use `?`
   - If at top level (command handler): log error and continue

   Example call site update:
   ```rust
   // Before
   config.save();

   // After (if can propagate)
   config.save()?;

   // After (if cannot propagate)
   if let Err(e) = config.save() {
       tracing::error!(error = %e, "Failed to save configuration");
   }
   ```

Search for call sites: `grep -rn "\.save()" app/src-tauri/src/`
  </action>
  <verify>
Run: `grep -n "\.expect(" core/src/context/config.rs`
Expected: No matches
Run: `cargo check -p core`
Expected: Compiles without errors
  </verify>
  <done>config.rs save() returns Result<(), ConfigError>, call sites handle errors</done>
</task>

<task type="auto">
  <name>Task 2: Add SessionDateMissing variant and convert reader.rs</name>
  <files>core/src/combat_log/error.rs, core/src/combat_log/reader.rs</files>
  <action>
**combat_log/error.rs - add new variant:**

Add to ReaderError enum:
```rust
#[derive(Debug, Error)]
pub enum ReaderError {
    // ... existing variants ...

    #[error("session date not initialized before tailing")]
    SessionDateMissing,
}
```

**combat_log/reader.rs line 126-131:**

Current code:
```rust
let session_date = self
    .state
    .read()
    .await
    .game_session_date
    .expect("failed to find game_session_date");
```

Replace with:
```rust
let session_date = self
    .state
    .read()
    .await
    .game_session_date
    .ok_or(ReaderError::SessionDateMissing)?;
```

This requires:
1. The function already returns `Result<_, _>` - verify the return type includes ReaderError
2. Import ReaderError if not already: `use super::error::ReaderError;` or `use crate::combat_log::error::ReaderError;`

Check the function signature of `tail_lines` to ensure it returns a Result that can propagate ReaderError.
  </action>
  <verify>
Run: `grep -n "\.expect(" core/src/combat_log/reader.rs`
Expected: No matches
Run: `cargo check -p core`
Expected: Compiles without errors
  </verify>
  <done>ReaderError::SessionDateMissing exists, reader.rs uses ok_or() instead of expect()</done>
</task>

<task type="auto">
  <name>Task 3: Verify zero expect/unwrap in production and fix any remaining</name>
  <files>core/src/**/*.rs</files>
  <action>
Run comprehensive scan for any remaining unwrap/expect calls in production code:

```bash
# Find all unwrap/expect in core/src, excluding test files
grep -rn "\.unwrap()\|\.expect(" core/src/ | grep -v "_tests.rs" | grep -v "tests.rs" | grep -v "#\[cfg(test)\]" | grep -v "mod tests"
```

For any remaining matches:
1. If in a function that can return Result: convert to `?` with appropriate error
2. If truly infallible (e.g., regex compilation): use `expect()` with clear context message explaining WHY it can't fail, OR move to lazy_static/OnceCell
3. If DSL test helper function: verify it's only called from tests

Document any remaining expect() calls that are kept with justification (e.g., "Regex is compile-time constant, cannot fail").

**Known exclusions (test code):**
- dsl/challenge.rs tests (lines 618, 620, 787, 789)
- dsl/loader.rs test functions (lines 424, 514, 524, 573)
- dsl/triggers/mod.rs tests (lines 662, 663, 677, 678)
- timers/preferences.rs tests (lines 288, 292)
- All *_tests.rs files
  </action>
  <verify>
Run: `grep -rn "\.unwrap()\|\.expect(" core/src/ | grep -v "_tests.rs" | grep -v "mod tests" | grep -v "#\[test\]"`
Expected: Zero matches (or only documented exceptions with justification)
Run: `cargo test -p core --lib`
Expected: All tests pass
  </verify>
  <done>Zero unwrap/expect calls in production core/src code</done>
</task>

</tasks>

<verification>
```bash
# Final verification: no unwrap/expect in production code
grep -rn "\.unwrap()\|\.expect(" core/src/ | grep -v "_tests.rs" | grep -v "tests.rs" | grep -v "mod tests" | grep -v "#\[test\]" | grep -v "#\[cfg(test)\]"

# Should return empty or only documented exceptions

# Full test suite
cargo test -p core --lib

# Check that app still compiles (config.save() callers)
cargo check -p app
```
</verification>

<success_criteria>
1. config.rs save() returns Result<(), ConfigError>
2. All save() call sites handle errors appropriately
3. ReaderError::SessionDateMissing variant exists
4. reader.rs uses .ok_or() instead of .expect()
5. Zero .unwrap() calls in core/src production code
6. Zero .expect() calls in core/src production code
7. All tests pass
8. App compiles successfully
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-error-handling/03-03-SUMMARY.md`
</output>
