---
phase: 03-core-error-handling
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - core/src/signal_processor/phase.rs
  - core/src/signal_processor/counter.rs
  - core/src/signal_processor/challenge.rs
  - core/src/signal_processor/processor.rs
autonomous: true

must_haves:
  truths:
    - "signal_processor/phase.rs has zero unwrap calls"
    - "signal_processor/counter.rs has zero unwrap calls"
    - "signal_processor/challenge.rs has zero unwrap calls"
    - "signal_processor/processor.rs has zero unwrap calls in production code"
  artifacts:
    - path: "core/src/signal_processor/phase.rs"
      provides: "Defensive early returns with error logging"
      contains: "tracing::error!"
    - path: "core/src/signal_processor/counter.rs"
      provides: "Defensive early returns with error logging"
      contains: "tracing::error!"
    - path: "core/src/signal_processor/challenge.rs"
      provides: "Defensive early return"
      contains: "let Some(enc)"
    - path: "core/src/signal_processor/processor.rs"
      provides: "Defensive early returns with error logging"
      contains: "tracing::error!"
  key_links:
    - from: "core/src/signal_processor/*.rs"
      to: "cache.current_encounter_mut()"
      via: "defensive Some pattern"
      pattern: "let Some\\(enc\\) = cache\\.current_encounter"
---

<objective>
Convert signal processor invariant unwraps to defensive early returns with logging.

Purpose: The signal processor files have 16 unwrap calls on `cache.current_encounter_mut()` that are logically "safe" (guarded by earlier checks) but violate the clean policy. Convert these to defensive early returns that log a BUG error if the invariant is violated, then return empty/continue.

Output: Four signal processor files with zero unwrap calls, defensive logging for invariant violations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-core-error-handling/03-RESEARCH.md

@core/src/signal_processor/phase.rs
@core/src/signal_processor/counter.rs
@core/src/signal_processor/challenge.rs
@core/src/signal_processor/processor.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert phase.rs and challenge.rs invariant unwraps</name>
  <files>core/src/signal_processor/phase.rs, core/src/signal_processor/challenge.rs</files>
  <action>
**phase.rs has 6 unwraps at lines 72, 134, 198, 236, 237, 268.**

Pattern in phase.rs - functions check encounter exists, then unwrap later:
```rust
let Some(enc) = cache.current_encounter() else { return Vec::new(); };
// ... computation using enc (immutable) ...
let enc = cache.current_encounter_mut().unwrap();  // BUG if this fails
```

Replace each unwrap with defensive early return:
```rust
let Some(enc) = cache.current_encounter_mut() else {
    tracing::error!("BUG: encounter disappeared mid-function in {fn_name}");
    return Vec::new();
};
```

For lines 236-237 which have:
```rust
let enc = cache.current_encounter().unwrap();
let def_idx = enc.active_boss_idx().unwrap();
```

Replace with:
```rust
let Some(enc) = cache.current_encounter() else {
    tracing::error!("BUG: no encounter in log_hp_transition");
    return;
};
let Some(def_idx) = enc.active_boss_idx() else {
    tracing::error!("BUG: no active boss in log_hp_transition");
    return;
};
```

**challenge.rs line 27:**
```rust
let ctx = cache.current_encounter().unwrap().challenge_context(&boss_npc_ids);
```

Already has a guard above returning if no encounter. Replace with:
```rust
let Some(enc) = cache.current_encounter() else {
    tracing::error!("BUG: encounter missing after guard in process_challenge_events");
    return;
};
let ctx = enc.challenge_context(&boss_npc_ids);
```

Ensure `use tracing;` is added to imports if not present.
  </action>
  <verify>
Run: `grep -n "\.unwrap()" core/src/signal_processor/phase.rs core/src/signal_processor/challenge.rs`
Expected: No matches
  </verify>
  <done>phase.rs has 0 unwraps, challenge.rs has 0 unwraps, both log BUG errors for invariant violations</done>
</task>

<task type="auto">
  <name>Task 2: Convert counter.rs and processor.rs invariant unwraps</name>
  <files>core/src/signal_processor/counter.rs, core/src/signal_processor/processor.rs</files>
  <action>
**counter.rs has 6 unwraps at lines 37, 56, 73, 120, 134, 151.**

Same pattern - functions extract data immutably at start (with guard), then need mutable access later.

Each unwrap follows this pattern inside a loop:
```rust
// Inside for loop after early return guard on cache.current_encounter()
if check_counter_trigger(...) {
    let enc = cache.current_encounter_mut().unwrap();
    // modify counter
}
```

Replace with continue + log:
```rust
if check_counter_trigger(...) {
    let Some(enc) = cache.current_encounter_mut() else {
        tracing::error!("BUG: encounter missing in check_counter_increments loop");
        continue;
    };
    // modify counter
}
```

For cases returning from function (not in loop), use `return signals;` or `return Vec::new();`

**processor.rs has 3 unwraps at lines 344, 424, 436.**

Line 344 is inside `if let Some(idx) = cache.detect_boss_encounter(...)`:
```rust
let enc = cache.current_encounter_mut().unwrap();
```

Replace with early return from that block:
```rust
let Some(enc) = cache.current_encounter_mut() else {
    tracing::error!("BUG: encounter missing after detect_boss_encounter");
    continue;  // or return signals depending on context
};
```

Lines 424 and 436 are inside a for loop over entities:
```rust
let enc = cache.current_encounter().unwrap();
// ...
let enc = cache.current_encounter_mut().unwrap();
```

Replace with continue:
```rust
let Some(enc) = cache.current_encounter() else {
    tracing::error!("BUG: encounter missing in update_hp_signals loop");
    continue;
};
// ...
let Some(enc) = cache.current_encounter_mut() else {
    tracing::error!("BUG: encounter missing in update_hp_signals loop (mut)");
    continue;
};
```

Ensure `use tracing;` is added to imports if not present.
  </action>
  <verify>
Run: `grep -n "\.unwrap()" core/src/signal_processor/counter.rs core/src/signal_processor/processor.rs | grep -v "_tests.rs"`
Expected: No matches (test file unwraps are allowed)
Run: `cargo test -p core signal_processor`
Expected: Tests pass
  </verify>
  <done>counter.rs has 0 production unwraps, processor.rs has 0 production unwraps, both log BUG errors</done>
</task>

</tasks>

<verification>
```bash
# Verify no unwrap calls remain in production signal processor files
grep -rn "\.unwrap()" core/src/signal_processor/ | grep -v "_tests.rs"

# Should return empty (no matches outside test files)

# Run signal processor tests
cargo test -p core signal_processor

# Run all core tests
cargo test -p core --lib
```
</verification>

<success_criteria>
1. Zero unwrap calls in signal_processor/phase.rs
2. Zero unwrap calls in signal_processor/counter.rs
3. Zero unwrap calls in signal_processor/challenge.rs
4. Zero unwrap calls in signal_processor/processor.rs (excluding test files)
5. All signal_processor tests pass
6. Each invariant violation logs a BUG-level error message
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-error-handling/03-02-SUMMARY.md`
</output>
