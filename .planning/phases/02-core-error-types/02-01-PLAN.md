---
phase: 02-core-error-types
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - core/Cargo.toml
  - core/src/combat_log/error.rs
  - core/src/combat_log/mod.rs
  - core/src/dsl/error.rs
  - core/src/dsl/mod.rs
autonomous: true

must_haves:
  truths:
    - "thiserror 2.x is available in core crate"
    - "combat_log module has typed error enums"
    - "dsl module has typed error enum"
  artifacts:
    - path: "core/Cargo.toml"
      provides: "thiserror dependency"
      contains: "thiserror"
    - path: "core/src/combat_log/error.rs"
      provides: "ParseError, ReaderError enums"
      exports: ["ParseError", "ReaderError"]
    - path: "core/src/dsl/error.rs"
      provides: "DslError enum"
      exports: ["DslError"]
  key_links:
    - from: "core/src/combat_log/error.rs"
      to: "thiserror"
      via: "derive macro"
      pattern: "#\\[derive.*Error\\]"
    - from: "core/src/dsl/error.rs"
      to: "thiserror"
      via: "derive macro"
      pattern: "#\\[derive.*Error\\]"
---

<objective>
Add thiserror dependency and create error types for combat_log and dsl modules.

Purpose: These are the highest-usage modules with Result<T, String> returns. Establishing their error types first provides patterns for remaining modules.

Output:
- thiserror 2.x added to core/Cargo.toml
- core/src/combat_log/error.rs with ParseError, ReaderError
- core/src/dsl/error.rs with DslError
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-error-types/02-RESEARCH.md
@core/Cargo.toml
@core/src/combat_log/mod.rs
@core/src/combat_log/reader.rs
@core/src/dsl/mod.rs
@core/src/dsl/loader.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add thiserror dependency</name>
  <files>core/Cargo.toml</files>
  <action>
Add thiserror 2.x to core/Cargo.toml dependencies:

```toml
thiserror = "2"
```

Place alphabetically among existing dependencies.
  </action>
  <verify>`cargo check -p baras-core` succeeds</verify>
  <done>thiserror is available for use in core crate</done>
</task>

<task type="auto">
  <name>Task 2: Create combat_log error types</name>
  <files>core/src/combat_log/error.rs, core/src/combat_log/mod.rs</files>
  <action>
Create `core/src/combat_log/error.rs` with error types for log parsing:

```rust
//! Error types for combat log parsing

use std::path::PathBuf;
use thiserror::Error;

/// Errors during combat log line parsing
#[derive(Debug, Error)]
pub enum ParseError {
    #[error("invalid line format at line {line_number}: expected bracket-delimited segments")]
    InvalidLineFormat { line_number: u64 },

    #[error("invalid timestamp at line {line_number}: {segment}")]
    InvalidTimestamp { line_number: u64, segment: String },

    #[error("invalid entity format at line {line_number}")]
    InvalidEntity { line_number: u64 },

    #[error("invalid effect format at line {line_number}")]
    InvalidEffect { line_number: u64 },

    #[error("invalid value format at line {line_number}: {detail}")]
    InvalidValue { line_number: u64, detail: String },
}

/// Errors during log file reading operations
#[derive(Debug, Error)]
pub enum ReaderError {
    #[error("failed to open log file {path}")]
    OpenFile {
        path: PathBuf,
        #[source]
        source: std::io::Error,
    },

    #[error("failed to memory map file {path}")]
    MemoryMap {
        path: PathBuf,
        #[source]
        source: std::io::Error,
    },

    #[error("encoding error in file {path}: not valid Windows-1252")]
    Encoding { path: PathBuf },

    #[error("failed to read file {path}")]
    ReadFile {
        path: PathBuf,
        #[source]
        source: std::io::Error,
    },

    #[error("failed to seek in file {path}")]
    Seek {
        path: PathBuf,
        #[source]
        source: std::io::Error,
    },
}
```

Update `core/src/combat_log/mod.rs` to:
1. Add `pub mod error;`
2. Re-export: `pub use error::{ParseError, ReaderError};`
  </action>
  <verify>`cargo check -p baras-core` succeeds</verify>
  <done>ParseError and ReaderError are defined and exported from combat_log module</done>
</task>

<task type="auto">
  <name>Task 3: Create dsl error types</name>
  <files>core/src/dsl/error.rs, core/src/dsl/mod.rs</files>
  <action>
Create `core/src/dsl/error.rs` with error types for DSL loading:

```rust
//! Error types for DSL definition loading

use std::path::PathBuf;
use thiserror::Error;

/// Errors during DSL definition loading and saving
#[derive(Debug, Error)]
pub enum DslError {
    #[error("failed to read {path}")]
    ReadFile {
        path: PathBuf,
        #[source]
        source: std::io::Error,
    },

    #[error("failed to parse TOML in {path}")]
    ParseToml {
        path: PathBuf,
        #[source]
        source: toml::de::Error,
    },

    #[error("failed to read directory {path}")]
    ReadDir {
        path: PathBuf,
        #[source]
        source: std::io::Error,
    },

    #[error("failed to serialize configuration")]
    Serialize(#[from] toml::ser::Error),

    #[error("failed to create directory {path}")]
    CreateDir {
        path: PathBuf,
        #[source]
        source: std::io::Error,
    },

    #[error("failed to write {path}")]
    WriteFile {
        path: PathBuf,
        #[source]
        source: std::io::Error,
    },

    #[error("invalid definition in {path}: {reason}")]
    InvalidDefinition { path: PathBuf, reason: String },
}
```

Update `core/src/dsl/mod.rs` to:
1. Add `pub mod error;`
2. Re-export: `pub use error::DslError;`
  </action>
  <verify>`cargo check -p baras-core` succeeds</verify>
  <done>DslError is defined and exported from dsl module</done>
</task>

</tasks>

<verification>
After all tasks:
1. `cargo check -p baras-core` passes
2. Error types are properly exported:
   - `baras_core::combat_log::ParseError`
   - `baras_core::combat_log::ReaderError`
   - `baras_core::dsl::DslError`
</verification>

<success_criteria>
- thiserror 2.x is a dependency in core/Cargo.toml
- combat_log/error.rs exists with ParseError and ReaderError enums
- dsl/error.rs exists with DslError enum
- All error types use #[derive(Debug, Error)] from thiserror
- Error types include context fields (paths, line numbers)
- Module mod.rs files export the error types
- `cargo check -p baras-core` passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-error-types/02-01-SUMMARY.md`
</output>
