---
phase: 02-core-error-types
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - core/src/query/error.rs
  - core/src/query/mod.rs
  - core/src/storage/error.rs
  - core/src/storage/mod.rs
autonomous: true

must_haves:
  truths:
    - "query module has typed error enum for DataFusion operations"
    - "storage module has typed error enum for parquet operations"
  artifacts:
    - path: "core/src/query/error.rs"
      provides: "QueryError enum"
      exports: ["QueryError"]
    - path: "core/src/storage/error.rs"
      provides: "StorageError enum"
      exports: ["StorageError"]
  key_links:
    - from: "core/src/query/error.rs"
      to: "datafusion::error::DataFusionError"
      via: "#[from] conversion"
      pattern: "DataFusion.*#\\[from\\]"
    - from: "core/src/storage/error.rs"
      to: "parquet::errors::ParquetError"
      via: "#[from] conversion"
      pattern: "Parquet.*#\\[from\\]"
---

<objective>
Create error types for query and storage modules (data layer).

Purpose: These modules handle DataFusion SQL queries and parquet file operations. Both have many functions returning Result<T, String> that need proper typed errors.

Output:
- core/src/query/error.rs with QueryError
- core/src/storage/error.rs with StorageError
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-error-types/02-RESEARCH.md
@core/src/query/mod.rs
@core/src/query/column_helpers.rs
@core/src/storage/mod.rs
@core/src/storage/writer.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create query error types</name>
  <files>core/src/query/error.rs, core/src/query/mod.rs</files>
  <action>
Create `core/src/query/error.rs` with error types for DataFusion queries:

```rust
//! Error types for data queries

use thiserror::Error;

/// Errors during data queries
#[derive(Debug, Error)]
pub enum QueryError {
    #[error("datafusion error")]
    DataFusion(#[from] datafusion::error::DataFusionError),

    #[error("arrow error")]
    Arrow(#[from] arrow::error::ArrowError),

    #[error("column {name} not found in result")]
    ColumnNotFound { name: String },

    #[error("unexpected column type for {name}: expected {expected}, got {actual}")]
    UnexpectedColumnType {
        name: String,
        expected: &'static str,
        actual: String,
    },

    #[error("no data available for query")]
    NoData,

    #[error("failed to register parquet file: {path}")]
    RegisterParquet {
        path: String,
        #[source]
        source: datafusion::error::DataFusionError,
    },

    #[error("SQL execution failed: {query}")]
    SqlExecution {
        query: String,
        #[source]
        source: datafusion::error::DataFusionError,
    },
}
```

Update `core/src/query/mod.rs` to:
1. Add `pub mod error;` near the top with other module declarations
2. Re-export: `pub use error::QueryError;`
  </action>
  <verify>`cargo check -p baras-core` succeeds</verify>
  <done>QueryError is defined and exported from query module</done>
</task>

<task type="auto">
  <name>Task 2: Create storage error types</name>
  <files>core/src/storage/error.rs, core/src/storage/mod.rs</files>
  <action>
Create `core/src/storage/error.rs` with error types for parquet operations:

```rust
//! Error types for data storage operations

use std::path::PathBuf;
use thiserror::Error;

/// Errors during parquet file operations
#[derive(Debug, Error)]
pub enum StorageError {
    #[error("failed to create file {path}")]
    CreateFile {
        path: PathBuf,
        #[source]
        source: std::io::Error,
    },

    #[error("failed to write parquet file {path}")]
    WriteParquet {
        path: PathBuf,
        #[source]
        source: parquet::errors::ParquetError,
    },

    #[error("arrow conversion error")]
    Arrow(#[from] arrow::error::ArrowError),

    #[error("parquet error")]
    Parquet(#[from] parquet::errors::ParquetError),

    #[error("failed to create data directory {path}")]
    CreateDir {
        path: PathBuf,
        #[source]
        source: std::io::Error,
    },

    #[error("IO error")]
    Io(#[from] std::io::Error),

    #[error("failed to build record batch: {reason}")]
    BuildRecordBatch { reason: String },
}
```

Update `core/src/storage/mod.rs` to:
1. Add `pub mod error;`
2. Re-export: `pub use error::StorageError;`
  </action>
  <verify>`cargo check -p baras-core` succeeds</verify>
  <done>StorageError is defined and exported from storage module</done>
</task>

</tasks>

<verification>
After all tasks:
1. `cargo check -p baras-core` passes
2. Error types are properly exported:
   - `baras_core::query::QueryError`
   - `baras_core::storage::StorageError`
3. DataFusion and parquet errors have #[from] conversions
</verification>

<success_criteria>
- query/error.rs exists with QueryError enum covering DataFusion operations
- storage/error.rs exists with StorageError enum covering parquet operations
- Error types use #[from] for underlying library errors (DataFusionError, ParquetError, ArrowError)
- Context-rich variants include relevant fields (paths, column names, queries)
- Module mod.rs files export the error types
- `cargo check -p baras-core` passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-error-types/02-02-SUMMARY.md`
</output>
