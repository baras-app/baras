---
phase: 04-backend-error-handling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/src-tauri/src/updater.rs
autonomous: true

must_haves:
  truths:
    - "Mutex lock poisoning does not crash the application"
    - "Tauri commands return Result errors instead of panicking"
    - "Poison recovery is logged at warn level"
  artifacts:
    - path: "app/src-tauri/src/updater.rs"
      provides: "Mutex poison recovery for PendingUpdate state"
      contains: "unwrap_or_else"
  key_links:
    - from: "app/src-tauri/src/updater.rs"
      to: "PendingUpdate Mutex"
      via: "poison recovery with into_inner()"
      pattern: "unwrap_or_else.*poisoned.*into_inner"
---

<objective>
Convert mutex lock unwraps in updater.rs to poison recovery pattern.

Purpose: Prevent IPC panics when checking/installing updates if mutex becomes poisoned from prior thread panic.
Output: All 3 mutex lock sites in updater.rs use poison recovery with logging.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-backend-error-handling/04-CONTEXT.md
@.planning/phases/04-backend-error-handling/04-RESEARCH.md

@app/src-tauri/src/updater.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert mutex locks to poison recovery</name>
  <files>app/src-tauri/src/updater.rs</files>
  <action>
Replace 3 `.lock().unwrap()` calls with poison recovery pattern:

**Line 46** (in check_for_update):
```rust
// Before
*state.0.lock().unwrap() = Some(update);

// After
*state.0.lock().unwrap_or_else(|poisoned| {
    tracing::warn!("PendingUpdate mutex poisoned, recovering");
    poisoned.into_inner()
}) = Some(update);
```

**Line 62** (in install_update command):
```rust
// Before
.and_then(|state| state.0.lock().unwrap().take())

// After
.and_then(|state| {
    state.0.lock()
        .unwrap_or_else(|poisoned| {
            tracing::warn!("PendingUpdate mutex poisoned, recovering");
            poisoned.into_inner()
        })
        .take()
})
```

**Line 111** (in check_update command):
```rust
// Before
*state.0.lock().unwrap() = Some(u);

// After
*state.0.lock().unwrap_or_else(|poisoned| {
    tracing::warn!("PendingUpdate mutex poisoned, recovering");
    poisoned.into_inner()
}) = Some(u);
```

Why poison recovery instead of returning error:
- PendingUpdate is transient state (just caches an Update object)
- If poisoned, recovering the inner data is safe
- Returning error would break update flow for users

Also replace the eprintln on line 29 with tracing::error while in the file:
```rust
// Before
eprintln!("Update check failed: {e}");

// After
tracing::error!(error = %e, "Update check failed");
```
  </action>
  <verify>
Run: `grep -n "\.unwrap()" app/src-tauri/src/updater.rs` - should return no matches
Run: `grep -c "unwrap_or_else" app/src-tauri/src/updater.rs` - should return 3
Run: `cargo check -p baras-app` - should compile without errors
  </verify>
  <done>
Zero .unwrap() calls in updater.rs. All mutex locks use poison recovery with warn-level logging.
  </done>
</task>

</tasks>

<verification>
After completion:
- `grep -rn "\.unwrap()" app/src-tauri/src/updater.rs` returns nothing
- `cargo check -p baras-app` compiles cleanly
- Code review confirms all 3 mutex lock sites use unwrap_or_else pattern
</verification>

<success_criteria>
- updater.rs has zero .unwrap() calls
- All mutex locks recover from poison with logging
- eprintln replaced with tracing
- Code compiles without warnings
</success_criteria>

<output>
After completion, create `.planning/phases/04-backend-error-handling/04-01-SUMMARY.md`
</output>
