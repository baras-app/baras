---
phase: 11-profile-system-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/src-tauri/src/service/handler.rs
  - app/src-tauri/src/overlay/manager.rs
  - app/src/app.rs
autonomous: true

must_haves:
  truths:
    - "Raid frames remain visible after profile switch"
    - "Raid frames remain visible after settings save"
    - "Profile selector visible even when no profiles exist"
    - "Empty profile state shows Default label and Save as Profile button"
  artifacts:
    - path: "app/src-tauri/src/service/handler.rs"
      provides: "Public refresh_raid_frames method"
      contains: "pub async fn refresh_raid_frames"
    - path: "app/src-tauri/src/overlay/manager.rs"
      provides: "Raid data resend after respawn"
      contains: "refresh_raid_frames"
    - path: "app/src/app.rs"
      provides: "Always-visible profile selector"
      contains: "profile-selector"
  key_links:
    - from: "manager.rs::refresh_settings"
      to: "service::refresh_raid_frames"
      via: "async call after raid respawn"
      pattern: "service\\.refresh_raid_frames"
---

<objective>
Fix raid frame re-render bug (PROF-02) and make profile selector always visible (PROF-03).

Purpose: Profile switching currently breaks raid frames - they disappear and only recover with visibility toggle workaround. Additionally, profile selector is hidden when no profiles exist, making it hard to discover.

Output: Raid frames survive profile switch and settings save. Profile selector always visible with Default state when empty.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-profile-system-fixes/11-CONTEXT.md
@.planning/phases/11-profile-system-fixes/11-RESEARCH.md

Key files:
@app/src-tauri/src/overlay/manager.rs (refresh_settings around line 725)
@app/src-tauri/src/service/handler.rs (refresh_raid_frames around line 353)
@app/src/app.rs (profile selector around line 813)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix raid frame re-render after profile switch</name>
  <files>
    app/src-tauri/src/service/handler.rs
    app/src-tauri/src/overlay/manager.rs
  </files>
  <action>
    **Root cause:** `refresh_settings` recreates raid overlay for grid size changes but doesn't send current raid data to the new overlay. The visibility toggle workaround works because `show_all` calls `send_initial_data` which triggers data flow.

    **Fix in handler.rs:**
    1. Change `refresh_raid_frames` from private to public:
       - Line ~353: Change `async fn refresh_raid_frames` to `pub async fn refresh_raid_frames`

    **Fix in manager.rs:**
    2. After raid respawn in `refresh_settings` (around line 779), trigger raid frame refresh:
       - After the raid overlay is inserted into state (line 779: `s.insert(result.handle);`)
       - Outside the lock scope, call `service.refresh_raid_frames().await;`
       - This sends `RefreshRaidFrames` command which builds current raid data and routes it to the overlay

    **Why this works:**
    - `RefreshRaidFrames` command (service/mod.rs line 704-713) calls `build_raid_frame_data` with `rearranging=true` to bypass early-out gates
    - Routes data via `overlay_tx` -> router -> raid overlay tx
    - Uses existing, proven code path
  </action>
  <verify>
    1. `cargo check -p baras` compiles without errors
    2. Manual test: Start app with raid overlay enabled, load a profile, verify frames don't disappear
    3. Manual test: Change raid settings and save, verify frames persist
  </verify>
  <done>
    Raid frames remain visible after profile switch and settings save (no visibility toggle workaround needed).
  </done>
</task>

<task type="auto">
  <name>Task 2: Make profile selector always visible</name>
  <files>app/src/app.rs</files>
  <action>
    **Current behavior:** Profile selector (line 813) only shows if `!profile_names().is_empty()`.

    **Fix in app.rs overlay settings profile section (around line 813-867):**

    1. Remove the `if !profile_names().is_empty()` condition wrapping the profile-selector div
    2. Update the profile selector content to handle empty state:

    When profiles exist (current behavior):
    - Show "Profiles:" label
    - Show dropdown with profile names
    - Show save button if profile is active

    When NO profiles exist (new behavior):
    - Show "Profile:" label (singular)
    - Show "Default" text (not a dropdown, just a span)
    - Show "Save as Profile" button that opens the profile creation flow

    **Implementation approach:**
    ```rust
    // Always show profile section
    div { class: "profile-selector",
        if profile_names().is_empty() {
            // Empty state
            span { class: "profile-label", "Profile:" }
            span { class: "profile-current", "Default" }
            button {
                class: "profile-save-btn",
                title: "Save current settings as a profile",
                onclick: move |_| {
                    // Navigate to settings panel profiles section
                    // Or show inline input like settings_panel does
                },
                i { class: "fa-solid fa-plus" }
                span { " Save as Profile" }
            }
        } else {
            // Existing profiles behavior (current code)
            span { class: "profile-label", "Profiles:" }
            select { ... }
            // save button if active profile
        }
    }
    ```

    3. For the "Save as Profile" button action, use the same pattern as settings_panel.rs:
       - Show an inline text input for profile name
       - Call `api::save_profile(&name)` then refresh profile_names signal
       - Or simply navigate to the Settings page profiles section

    **Simpler approach:** Just show "Save as Profile" button that calls save_profile with a generated name like "Profile 1", then user can rename in settings. This avoids UI complexity.

    **Note:** Keep styling consistent with existing profile selector. The button should match btn-control style.
  </action>
  <verify>
    1. `dx build` or hot reload succeeds
    2. With no profiles: See "Profile: Default" with "Save as Profile" button
    3. With profiles: See "Profiles:" dropdown with save button (unchanged)
    4. Clicking "Save as Profile" creates a profile
  </verify>
  <done>
    Profile selector visible in overlay settings even with no profiles. Shows "Default" state with option to create first profile.
  </done>
</task>

</tasks>

<verification>
1. Backend compiles: `cargo check -p baras`
2. Frontend builds: `dx build` or hot reload
3. Integration test:
   - Start with no profiles, verify selector shows "Default"
   - Create profile via "Save as Profile"
   - Switch profiles, verify raid frames persist
   - Save overlay settings, verify raid frames persist
</verification>

<success_criteria>
- PROF-02: Raid frames remain visible through profile switch and settings save
- PROF-03: Profile selector always visible with appropriate empty/populated states
- No regressions to existing profile or overlay functionality
</success_criteria>

<output>
After completion, create `.planning/phases/11-profile-system-fixes/11-01-SUMMARY.md`
</output>
