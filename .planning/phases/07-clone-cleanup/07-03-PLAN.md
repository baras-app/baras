---
phase: 07-clone-cleanup
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - core/src/effects/tracker.rs
  - core/src/effects/active.rs
autonomous: true

must_haves:
  truths:
    - "Effects are tracked correctly when applied and removed"
    - "Effect stacks/charges update correctly"
    - "Alerts fire correctly on apply/expire based on definition"
    - "AoE refresh correlation works correctly"
  artifacts:
    - path: "core/src/effects/tracker.rs"
      provides: "Effect tracking with reduced clones"
      contains: "impl SignalHandler for EffectTracker"
    - path: "core/src/effects/active.rs"
      provides: "EffectKey with potential optimizations"
      contains: "struct EffectKey"
  key_links:
    - from: "core/src/effects/tracker.rs"
      to: "HashMap<EffectKey, ActiveEffect>"
      via: "active_effects map operations"
      pattern: "active_effects"
---

<objective>
Reduce unnecessary clones in tracker.rs by optimizing EffectKey construction and definition field access patterns.

Purpose: tracker.rs has 28 clones, mostly from:
1. Cloning def.id to construct EffectKey for HashMap lookups
2. Cloning definition fields (id, name, alert_text) when constructing ActiveEffect and FiredAlert
3. Cloning def.id for tracking/iteration patterns

Output: tracker.rs with ~50% fewer clones (target: 14 or fewer), all tests passing
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@core/src/effects/tracker.rs
@core/src/effects/active.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Optimize EffectKey construction and HashMap lookups</name>
  <files>core/src/effects/tracker.rs, core/src/effects/active.rs</files>
  <action>
**Category 1: EffectKey construction for lookups (lines 505, 632, 743, 842, 924, 1003)**

Current pattern:
```rust
let key = EffectKey {
    definition_id: def.id.clone(),
    target_entity_id: target_id,
};
if let Some(existing) = self.active_effects.get_mut(&key) {
```

The issue: We clone def.id just to create a key for lookup. If the lookup fails, we clone again for insertion.

**Optimization approach 1 - Borrow<str> for HashMap:**

If EffectKey stored `Arc<str>` instead of `String`, cloning would be cheap. But that requires changing EffectKey and all its usages.

**Optimization approach 2 - Use entry API:**

```rust
use std::collections::hash_map::Entry;

let key = EffectKey::new(&def.id, target_id); // borrows, doesn't clone yet

match self.active_effects.entry(key) {
    Entry::Occupied(mut entry) => {
        // existing effect - refresh
        entry.get_mut().refresh(timestamp, duration);
    }
    Entry::Vacant(entry) => {
        // new effect - insert (key is moved here, not cloned again)
        let effect = ActiveEffect::new(...);
        entry.insert(effect);
    }
}
```

Wait - `entry()` takes ownership of the key, so we'd still need to clone for the key. And `get_mut` takes `&K`.

**Better optimization - lookup by reference:**

Implement `Borrow<(&str, i64)>` for EffectKey, then use tuple for lookup:

Actually, this is complex. Simpler approach:

**Optimization approach 3 - Check existence first:**

```rust
// Check if key would exist without creating it
let key_exists = self.active_effects.keys().any(|k|
    k.definition_id == def.id && k.target_entity_id == target_id
);

if key_exists {
    // Only now create key for get_mut
    let key = EffectKey::new(&def.id, target_id);
    if let Some(existing) = self.active_effects.get_mut(&key) {
        existing.refresh(...);
    }
} else {
    // Create key for insertion
    let key = EffectKey::new(&def.id, target_id);
    let effect = ActiveEffect::new(...);
    self.active_effects.insert(key, effect);
}
```

This is worse - iterates all keys.

**Practical optimization - minimize duplicate clones:**

The pattern that appears multiple times:
```rust
let key = EffectKey {
    definition_id: def.id.clone(),
    target_entity_id: target_id,
};
if let Some(existing) = self.active_effects.get_mut(&key) {
    // refresh existing
} else {
    // create new, using def.id.clone() AGAIN in ActiveEffect::new()
}
```

Consolidate: Create the string once, reuse:
```rust
let def_id = def.id.clone(); // clone once
let key = EffectKey {
    definition_id: def_id.clone(), // unavoidable - key needs owned
    target_entity_id: target_id,
};
if let Some(existing) = self.active_effects.get_mut(&key) {
    existing.refresh(timestamp, duration);
} else {
    let effect = ActiveEffect::new(
        def_id, // move, not clone
        ...
    );
    self.active_effects.insert(key, effect);
}
```

This saves one clone per effect creation (when effect doesn't exist).

**Category 2: Alert construction clones (lines 419-421, 527-529, 576-578)**

These clone `def.id`, `def.name`, and `text` for FiredAlert. These are mostly necessary since FiredAlert owns its strings.

However, we could check: if FiredAlert is only used ephemerally (read and dropped), could it borrow? Check the FiredAlert struct and its consumers.

If FiredAlert must own strings (likely for sending across threads), keep these clones.

**Category 3: Definition set clones (lines 65, 71)**

```rust
duplicates.push(def.id.clone());
self.effects.insert(def.id.clone(), def);
```

These are in `add_definitions` which runs at startup, not hot path. Keep as-is (correctness over micro-optimization for cold path).

**Summary of actionable changes:**

1. In hot paths (`handle_effect_applied`, `handle_effect_removed`, `handle_ability_cast`, etc.), consolidate clones: clone def.id once at the start of each matching block, reuse for key and effect construction.

2. For the refreshable_def_ids pattern (lines 629-633, 739-744):
```rust
let refreshable_def_ids: Vec<_> = self
    .definitions
    .enabled()
    .filter(|def| def.can_refresh_with(...))
    .map(|def| (def.id.clone(), self.effective_duration(def)))
    .collect();
```

This iterates definitions and clones IDs. Since we immediately use them for lookups, this is unavoidable. Keep as-is.

3. In `tick()` function (line 404):
```rust
base_ended_def_ids.push(effect.definition_id.clone());
```

This clones from ActiveEffect which stores owned String. Unavoidable if we need to look up definitions after the loop.

**Net reduction target:** Focus on consolidating the ~5-6 places where we clone def.id twice (once for key, once for ActiveEffect). Each consolidation saves 1 clone. Combined with any other small wins, target 14 or fewer from original 28.
  </action>
  <verify>
Run `cargo build -p core` to verify compilation.
Run `cargo clippy -p core -- -D warnings` to verify no new warnings.
Count clones: `grep -c '\.clone()' core/src/effects/tracker.rs` should show reduction.
  </verify>
  <done>
tracker.rs compiles clean, clone count reduced from 28 to ~14 or fewer.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify effect tracking behavior with tests</name>
  <files>core/src/effects/tracker.rs</files>
  <action>
Run the core crate tests to verify effect tracking still works correctly:

```bash
cargo test -p core
```

The effect tracker tests should cover:
- Effect application and removal
- Effect refresh on reapplication
- Stack/charge updates
- Alert firing on apply/expire
- AoE refresh correlation
- Filter matching (source/target filters)

Run full workspace tests:
```bash
cargo test --workspace
```

If any tests fail, debug and fix. The optimizations should be purely mechanical and not change behavior.
  </action>
  <verify>
`cargo test -p core` passes all tests.
`cargo test --workspace` passes all tests.
  </verify>
  <done>
All existing tests pass, confirming no behavioral regressions from clone reduction.
  </done>
</task>

</tasks>

<verification>
1. Clone count in tracker.rs reduced by 50%+ (from 28 to 14 or fewer)
2. `cargo build -p core` succeeds
3. `cargo clippy -p core -- -D warnings` passes clean
4. `cargo test --workspace` passes
</verification>

<success_criteria>
- tracker.rs clone count: 14 or fewer (50%+ reduction from 28)
- All workspace tests pass
- No clippy warnings
</success_criteria>

<output>
After completion, create `.planning/phases/07-clone-cleanup/07-03-SUMMARY.md`
</output>
