---
phase: 07-clone-cleanup
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - core/src/timers/manager.rs
  - core/src/timers/active.rs
autonomous: true

must_haves:
  truths:
    - "Timers start correctly when signals match triggers"
    - "Timers expire and chain to next timers correctly"
    - "Timer cancellation works correctly"
    - "Fired alerts are collected and returned correctly"
  artifacts:
    - path: "core/src/timers/manager.rs"
      provides: "Timer management with reduced clones"
      contains: "impl SignalHandler for TimerManager"
    - path: "core/src/timers/active.rs"
      provides: "TimerKey with potential Borrow impl"
      contains: "struct TimerKey"
  key_links:
    - from: "core/src/timers/manager.rs"
      to: "HashMap<TimerKey, ActiveTimer>"
      via: "active_timers map operations"
      pattern: "active_timers"
---

<objective>
Reduce unnecessary clones in manager.rs by optimizing HashMap key operations and ID tracking patterns.

Purpose: manager.rs has 36 clones, mostly from:
1. Cloning TimerKey when iterating HashMap before mutation (collect keys pattern)
2. Cloning definition IDs into tracking vectors (started_this_tick, expired_this_tick, cancelled_this_tick)
3. Returning cloned vectors from accessor methods

Output: manager.rs with ~50% fewer clones (target: 18 or fewer), all tests passing
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@core/src/timers/manager.rs
@core/src/timers/active.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Optimize HashMap key operations and tracking vectors</name>
  <files>core/src/timers/manager.rs, core/src/timers/active.rs</files>
  <action>
**Category 1: HashMap iteration patterns (lines 506-523, 531-550, 562-581, 595-606, 671-688)**

These patterns collect keys by cloning, then iterate to remove. This is necessary because you can't mutate HashMap while iterating. However, we can reduce intermediate clones.

Current pattern:
```rust
let keys_to_cancel: Vec<_> = self.active_timers
    .iter()
    .filter_map(|(key, timer)| {
        if condition { Some(key.clone()) } else { None }
    })
    .collect();
for key in keys_to_cancel {
    self.cancelled_this_tick.push(key.definition_id.clone());
    self.active_timers.remove(&key);
}
```

Optimization - extract just the definition_id during collection:
```rust
let keys_to_cancel: Vec<_> = self.active_timers
    .iter()
    .filter_map(|(key, timer)| {
        if condition { Some(key.clone()) } else { None }
    })
    .collect();
for key in &keys_to_cancel {
    self.cancelled_this_tick.push(key.definition_id.clone());
}
for key in keys_to_cancel {
    self.active_timers.remove(&key);
}
```

Actually, better: collect definition_ids separately from keys:
```rust
let (keys_to_cancel, def_ids): (Vec<_>, Vec<_>) = self.active_timers
    .iter()
    .filter_map(|(key, _timer)| {
        if condition {
            Some((key.clone(), key.definition_id.clone()))
        } else {
            None
        }
    })
    .unzip();
self.cancelled_this_tick.extend(def_ids);
for key in keys_to_cancel {
    self.active_timers.remove(&key);
}
```

Wait - this doesn't reduce clones. The real issue is that `TimerKey.definition_id` is a `String`, so every clone of the key clones the string.

**Better approach - use entry API or retain where possible:**

For cancellation patterns, use `retain` to avoid collecting keys:
```rust
let mut cancelled = Vec::new();
self.active_timers.retain(|key, timer| {
    if let Some(def) = self.definitions.get(&timer.definition_id)
        && let Some(ref cancel_trigger) = def.cancel_trigger
        && trigger_matches(cancel_trigger)
    {
        cancelled.push(key.definition_id.clone());
        false // remove
    } else {
        true // keep
    }
});
self.cancelled_this_tick.extend(cancelled);
```

This still clones definition_id, but avoids cloning the entire TimerKey.

**Category 2: Tracking vector accessor clones (lines 395, 400, 405)**

Current:
```rust
pub fn expired_timer_ids(&self) -> Vec<String> {
    self.expired_this_tick.clone()
}
```

Change to return slice reference:
```rust
pub fn expired_timer_ids(&self) -> &[String] {
    &self.expired_this_tick
}
```

Check callers - if they need ownership, caller can clone. Most likely they just iterate.

**Category 3: Timer construction clones (lines 437-494)**

These clone def.id, def.name, etc. into new structs. These are necessary when creating new instances. However:

- `def.audio.countdown_voice.clone()` and similar - if AudioConfig already has the data, consider passing by reference and cloning inside ActiveTimer::new()

Actually, most timer construction clones ARE necessary because ActiveTimer owns its data. Focus on categories 1 and 2.

**Category 4: expired_ids clone (line 647)**

```rust
let expired_ids = self.expired_this_tick.clone();
for expired_id in &expired_ids {
```

Change to iterate by reference directly:
```rust
let expired_ids: Vec<_> = self.expired_this_tick.iter().cloned().collect();
```

Wait, that's the same. The issue is we need to call methods on self while iterating.

Better: iterate by index:
```rust
for i in 0..self.expired_this_tick.len() {
    let expired_id = &self.expired_this_tick[i];
    // ... but we call self methods that may modify expired_this_tick
}
```

Actually, since `process_expirations` clears `expired_this_tick` at the start (line 590), and we're only reading it later in the same function, the clone IS necessary for the for-loop below that calls `self.cancel_timers_on_expire()`.

Keep this clone but document why it's needed.

**Summary of actionable changes:**

1. Change `expired_timer_ids`, `started_timer_ids`, `cancelled_timer_ids` to return `&[String]`
2. Use `retain` pattern instead of collect-then-remove where possible
3. For `process_expirations` line 647, keep the clone (necessary for self-method calls) but could use a different approach: collect IDs during the first loop instead of cloning the whole vector
  </action>
  <verify>
Run `cargo build -p core` to verify compilation.
Run `cargo clippy -p core -- -D warnings` to verify no new warnings.
Count clones: `grep -c '\.clone()' core/src/timers/manager.rs` should show reduction.
  </verify>
  <done>
manager.rs compiles clean, clone count reduced from 36 to ~18 or fewer.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update callers of changed APIs and verify tests</name>
  <files>core/src/timers/manager.rs</files>
  <action>
If accessor methods were changed from `-> Vec<String>` to `-> &[String]`, check and update callers:

```bash
rg "expired_timer_ids|started_timer_ids|cancelled_timer_ids" --type rust
```

Update any callers that need owned data to call `.to_vec()` or iterate by reference.

Run tests:
```bash
cargo test -p core
cargo test --workspace
```

The timer manager has comprehensive tests in `manager_tests.rs` that should catch any regressions.
  </action>
  <verify>
`cargo test -p core` passes all tests.
`cargo test --workspace` passes all tests.
  </verify>
  <done>
All existing tests pass, confirming no behavioral regressions from clone reduction.
  </done>
</task>

</tasks>

<verification>
1. Clone count in manager.rs reduced by 50%+ (from 36 to 18 or fewer)
2. `cargo build -p core` succeeds
3. `cargo clippy -p core -- -D warnings` passes clean
4. `cargo test --workspace` passes
</verification>

<success_criteria>
- manager.rs clone count: 18 or fewer (50%+ reduction from 36)
- All workspace tests pass
- No clippy warnings
</success_criteria>

<output>
After completion, create `.planning/phases/07-clone-cleanup/07-02-SUMMARY.md`
</output>
