---
phase: 05-frontend-error-handling
plan: 04
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - app/src/api.rs
  - app/src/app.rs
autonomous: true

must_haves:
  truths:
    - "API functions that can fail return Result"
    - "Failed operations show toast notifications"
    - "Silent retry happens once before showing error"
    - "User sees friendly error message, not technical details"
  artifacts:
    - path: "app/src/api.rs"
      provides: "API functions returning Result<T, String>"
      contains: "-> Result<"
    - path: "app/src/app.rs"
      provides: "Components showing toast on API failure"
      contains: "use_toast"
  key_links:
    - from: "app/src/app.rs"
      to: "app/src/api.rs"
      via: "API calls with error handling"
      pattern: "if let Err.*toast\\.show"
---

<objective>
Convert fire-and-forget API functions to return Result and wire error handling to toast notifications.

Purpose: Users see feedback when operations fail (config saves, profile operations, etc.) instead of silent failures. This completes the error handling loop from backend to user.

Output: API functions return Result, app.rs shows toasts on failure.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-frontend-error-handling/05-CONTEXT.md
@.planning/phases/05-frontend-error-handling/05-RESEARCH.md
@.planning/phases/05-frontend-error-handling/05-01-SUMMARY.md
@app/src/api.rs
@app/src/app.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert API functions to return Result</name>
  <files>app/src/api.rs</files>
  <action>
Update `app/src/api.rs` to convert functions that currently return `bool` or ignore errors to return `Result<T, String>`:

1. `update_config` - currently returns `bool`:
   ```rust
   pub async fn update_config(config: &AppConfig) -> Result<(), String> {
       try_invoke("update_config", build_args("config", config)).await?;
       Ok(())
   }
   ```

2. `save_profile` - currently returns `bool`:
   ```rust
   pub async fn save_profile(name: &str) -> Result<(), String> {
       try_invoke("save_profile", build_args("name", &name)).await?;
       Ok(())
   }
   ```

3. `load_profile` - currently returns `bool`:
   ```rust
   pub async fn load_profile(name: &str) -> Result<(), String> {
       try_invoke("load_profile", build_args("name", &name)).await?;
       Ok(())
   }
   ```

4. `delete_profile` - currently returns `bool`:
   ```rust
   pub async fn delete_profile(name: &str) -> Result<(), String> {
       try_invoke("delete_profile", build_args("name", &name)).await?;
       Ok(())
   }
   ```

5. `open_historical_file` - currently returns `bool`:
   ```rust
   pub async fn open_historical_file(path: &str) -> Result<(), String> {
       try_invoke("open_historical_file", build_args("path", &path)).await?;
       Ok(())
   }
   ```

6. `resume_live_tailing` - currently returns `bool`:
   ```rust
   pub async fn resume_live_tailing() -> Result<(), String> {
       try_invoke("resume_live_tailing", JsValue::NULL).await?;
       Ok(())
   }
   ```

Keep the existing `try_invoke` function - it already handles promise rejections and returns `Result<JsValue, String>`.

Note: Some functions like `show_overlay`, `hide_overlay` can remain returning `bool` since overlay toggle failures are non-critical and the UI already handles the state.
  </action>
  <verify>
Compile check: `cd /home/prescott/baras/app && cargo check --target wasm32-unknown-unknown 2>&1 | head -100`
Should show errors in app.rs where these are called (expected - we fix in next task).
  </verify>
  <done>API functions update_config, save_profile, load_profile, delete_profile, open_historical_file, resume_live_tailing return Result<T, String>.</done>
</task>

<task type="auto">
  <name>Task 2: Wire error handling with toast notifications</name>
  <files>app/src/app.rs</files>
  <action>
Update `app/src/app.rs` to handle API errors and show toasts:

1. Add import:
   ```rust
   use crate::components::{ToastFrame, ToastSeverity, use_toast, use_toast_provider};
   ```

2. For each spawn block that calls the converted API functions, get toast and handle errors:

Pattern for config saves (multiple locations):
```rust
// Before:
spawn(async move {
    if let Some(mut cfg) = api::get_config().await {
        cfg.some_field = value;
        api::update_config(&cfg).await;
    }
});

// After:
spawn(async move {
    let toast = use_toast();
    if let Some(mut cfg) = api::get_config().await {
        cfg.some_field = value;
        if let Err(e) = api::update_config(&cfg).await {
            toast.show(format!("Failed to save settings: {}", e), ToastSeverity::Normal);
        }
    }
});
```

Key locations to update:

a) Config saves (~15 locations):
   - Log directory change
   - Hotkey saves
   - Auto-delete settings
   - Retention days
   - Minimize to tray
   - Parsely settings
   - Audio settings
   - Hide small files toggle
   - Show only bosses toggle
   - Overlay settings changes

b) Profile operations:
   - `save_profile` calls - show toast on error
   - `load_profile` calls - show toast on error
   - `delete_profile` calls (if any) - show toast on error

c) File browser:
   - `open_historical_file` - show toast on error

d) Live tailing:
   - `resume_live_tailing` - show toast on error

For each error, use user-friendly message:
- Config: "Failed to save settings"
- Profile: "Failed to save profile" / "Failed to load profile"
- File open: "Failed to open log file"
- Resume: "Failed to resume live tailing"

Note: The toast system was set up in Plan 01 with use_toast_provider at app root. Inside spawn blocks, call use_toast() to get the manager.

IMPORTANT: Inside async blocks within spawn(), you need to capture the toast manager BEFORE the async block:
```rust
let toast = use_toast();
spawn(async move {
    // toast is captured and available here
    if let Err(e) = api::something().await {
        toast.show("Error message", ToastSeverity::Normal);
    }
});
```
  </action>
  <verify>
Compile check: `cd /home/prescott/baras/app && cargo check --target wasm32-unknown-unknown 2>&1 | head -50`
Should compile without errors.
Count toast usage: `grep -c "toast.show" /home/prescott/baras/app/src/app.rs` returns >= 10
  </verify>
  <done>App.rs handles all API errors with toast notifications. User sees friendly error messages on failure.</done>
</task>

</tasks>

<verification>
1. `cd /home/prescott/baras/app && cargo check --target wasm32-unknown-unknown` compiles without errors
2. API functions return Result (grep for "-> Result<" in api.rs)
3. App.rs uses toast.show for error handling (grep count >= 10)
4. No unwrap() calls on the converted API functions
</verification>

<success_criteria>
- Core API functions (config, profile, file ops) return Result<T, String>
- All call sites handle errors with toast.show()
- Error messages are user-friendly (not technical stack traces)
- App compiles and runs without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-frontend-error-handling/05-04-SUMMARY.md`
</output>
