---
phase: 01-logging-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - app/src-tauri/src/lib.rs
  - parse-worker/src/main.rs
autonomous: true

must_haves:
  truths:
    - "Application starts with tracing subscriber active"
    - "Debug and error messages appear in structured log output"
    - "Log level is configurable via RUST_LOG environment variable"
    - "Debug builds default to DEBUG level, release builds to INFO"
  artifacts:
    - path: "app/src-tauri/src/lib.rs"
      provides: "Subscriber initialization for main app"
      contains: "tracing_subscriber::fmt"
    - path: "parse-worker/src/main.rs"
      provides: "Subscriber initialization for parse worker"
      contains: "tracing_subscriber::fmt"
  key_links:
    - from: "app/src-tauri/src/lib.rs"
      to: "tracing_subscriber"
      via: "subscriber.init() call"
      pattern: "\\.init\\(\\)"
    - from: "parse-worker/src/main.rs"
      to: "tracing_subscriber"
      via: "subscriber.init() call"
      pattern: "\\.init\\(\\)"
---

<objective>
Initialize tracing subscriber in app/src-tauri and parse-worker binaries.

Purpose: Enable structured logging throughout the application with configurable log levels.
Output: Both binaries initialize tracing on startup, with sensible defaults and RUST_LOG override support.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-logging-foundation/01-RESEARCH.md
@app/src-tauri/src/lib.rs
@parse-worker/src/main.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize tracing in app/src-tauri</name>
  <files>app/src-tauri/src/lib.rs</files>
  <action>
Add tracing subscriber initialization at the very START of the `run()` function, BEFORE `tauri::Builder::default()`.

1. Add imports at top of file:
```rust
use tracing_subscriber::filter::EnvFilter;
```

2. Add compile-time default log level constants (before the `run()` function):
```rust
#[cfg(debug_assertions)]
const DEFAULT_LOG_LEVEL: tracing::Level = tracing::Level::DEBUG;

#[cfg(not(debug_assertions))]
const DEFAULT_LOG_LEVEL: tracing::Level = tracing::Level::INFO;
```

3. At the very start of `run()`, BEFORE the `let overlay_state = ...` line, add:
```rust
// Initialize tracing subscriber FIRST
let filter = EnvFilter::builder()
    .with_default_directive(DEFAULT_LOG_LEVEL.into())
    .from_env_lossy();

tracing_subscriber::fmt()
    .with_env_filter(filter)
    .with_target(true)
    .with_thread_ids(false)
    .with_file(false)
    .init();

tracing::info!("BARAS starting up");
```

4. Replace the existing eprintln in the setup closure with tracing::error:
```rust
// Change this:
if let Err(e) = baras_core::storage::clear_data_dir() {
    eprintln!("[STARTUP] Failed to clear data directory: {}", e);
}

// To this:
if let Err(e) = baras_core::storage::clear_data_dir() {
    tracing::error!(error = %e, "Failed to clear data directory");
}
```

Key points:
- Subscriber init MUST be first in run() - before any code that might log
- Use `from_env_lossy()` so invalid RUST_LOG values don't crash the app
- `with_target(true)` shows module paths in output (useful for filtering)
- `with_thread_ids(false)` and `with_file(false)` reduce noise
  </action>
  <verify>Run `cargo build -p app` then `RUST_LOG=debug cargo run -p app 2>&1 | head -20` - should see "BARAS starting up" in structured format</verify>
  <done>app/src-tauri initializes tracing subscriber on startup, startup message visible in logs</done>
</task>

<task type="auto">
  <name>Task 2: Initialize tracing in parse-worker</name>
  <files>parse-worker/src/main.rs</files>
  <action>
Add tracing subscriber initialization at the start of `main()`, before any other code.

1. Add imports at top of file (with other imports):
```rust
use tracing_subscriber::filter::EnvFilter;
```

2. At the very start of `main()`, BEFORE the `let args: Vec<String> = ...` line, add:
```rust
// Initialize tracing subscriber (parse-worker is separate process, needs its own)
let filter = EnvFilter::builder()
    .with_default_directive(tracing::Level::INFO.into())
    .from_env_lossy();

tracing_subscriber::fmt()
    .with_env_filter(filter)
    .with_target(true)
    .init();
```

3. Replace the existing eprintln calls with tracing macros:

```rust
// Change usage error (line ~546-549):
// From:
eprintln!("Usage: baras-parse-worker <file_path> <session_id> <output_dir> [definitions_dir]");
// To:
tracing::error!("Usage: baras-parse-worker <file_path> <session_id> <output_dir> [definitions_dir]");

// Change output dir error (line ~558-559):
// From:
eprintln!("Failed to create output dir: {}", e);
// To:
tracing::error!(error = %e, "Failed to create output dir");

// Change bundled definitions success (line ~571-574):
// From:
eprintln!("[PARSE-WORKER] Loaded {} bundled boss definitions", bosses.len());
// To:
tracing::debug!(count = bosses.len(), "Loaded bundled boss definitions");

// Change bundled definitions error (line ~577):
// From:
eprintln!("[PARSE-WORKER] Failed to load bundled definitions: {}", e);
// To:
tracing::warn!(error = %e, "Failed to load bundled definitions");

// Change user definitions success (line ~588-591):
// From:
eprintln!("[PARSE-WORKER] Loaded {} user boss definitions", user_bosses.len());
// To:
tracing::debug!(count = user_bosses.len(), "Loaded user boss definitions");

// Change user definitions error (line ~612):
// From:
eprintln!("[PARSE-WORKER] Failed to load user definitions: {}", e);
// To:
tracing::warn!(error = %e, "Failed to load user definitions");

// Change parse error (line ~630):
// From:
eprintln!("Parse error: {}", e);
// To:
tracing::error!(error = %e, "Parse error");
```

4. Remove the debug logging code for shields (lines ~312-328) - this is temporary debug code writing to /tmp that should be removed:
```rust
// DELETE this entire block:
// DEBUG
use std::io::Write;
static DEBUG_COUNT: std::sync::atomic::AtomicUsize = std::sync::atomic::AtomicUsize::new(0);
let count = DEBUG_COUNT.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
if count < 10 {
    let mut f = std::fs::OpenOptions::new().create(true).append(true).open("/tmp/parse_worker_shield.txt").unwrap();
    let _ = writeln!(f, "dmg_absorbed={}, has_enc={}", event.details.dmg_absorbed, cache.current_encounter().is_some());
}
// ... and the second debug block inside the if let Some(enc)
```

Key points:
- Parse-worker is a separate process, so it needs its own subscriber (not shared with main app)
- Use INFO as default (not DEBUG) since parse-worker output goes to main app
- Remove the hacky debug file logging - proper tracing replaces it
  </action>
  <verify>Run `cargo build -p baras-parse-worker` - should compile. The worker is spawned by the app, so direct testing requires a log file.</verify>
  <done>parse-worker initializes tracing subscriber on startup, eprintln replaced with tracing macros, debug file logging removed</done>
</task>

</tasks>

<verification>
1. `cargo build --workspace` succeeds
2. `grep -n "eprintln" app/src-tauri/src/lib.rs` returns no matches
3. `grep -n "eprintln" parse-worker/src/main.rs` returns no matches
4. `grep -n "/tmp/parse_worker" parse-worker/src/main.rs` returns no matches
5. `grep -n "tracing::info" app/src-tauri/src/lib.rs` shows startup message
6. Running `RUST_LOG=debug cargo run -p app` shows structured log output
</verification>

<success_criteria>
- app/src-tauri/src/lib.rs initializes tracing at start of run()
- parse-worker/src/main.rs initializes tracing at start of main()
- All eprintln calls in both files replaced with tracing macros
- Debug file logging removed from parse-worker
- RUST_LOG environment variable controls log level
- Debug builds default to DEBUG, release to INFO (for app)
- Application starts and logs "BARAS starting up"
</success_criteria>

<output>
After completion, create `.planning/phases/01-logging-foundation/01-02-SUMMARY.md`
</output>
