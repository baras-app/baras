---
phase: 15-objc2-migration
plan: 03
type: execute
wave: 3
depends_on: ["15-02"]
files_modified:
  - overlay/src/platform/macos.rs
autonomous: true

must_haves:
  truths:
    - "NSWindow created using objc2-app-kit types"
    - "NSApplication accessed via NSApplication::sharedApplication()"
    - "Window includes setReleasedWhenClosed(false) for proper memory management"
    - "All Objective-C objects use Retained<T> smart pointers"
    - "No raw id pointers remain in struct fields"
  artifacts:
    - path: "overlay/src/platform/macos.rs"
      provides: "Full objc2-app-kit window management"
      contains: "NSApplication::sharedApplication"
  key_links:
    - from: "MacOSOverlay::new"
      to: "NSWindow"
      via: "objc2-app-kit initWithContentRect"
      pattern: "initWithContentRect_styleMask_backing_defer"
    - from: "MacOSOverlay"
      to: "Retained<NSWindow>"
      via: "struct field"
      pattern: "window: Retained<NSWindow>"
---

<objective>
Migrate window and application management from cocoa to objc2-app-kit.

Purpose: Complete the objc2 migration by replacing all cocoa::appkit usage with objc2-app-kit. This enables removal of deprecated dependencies in Phase 16.

Output: Full objc2-app-kit usage for NSWindow, NSApplication, NSScreen, NSEvent, NSColor.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/STACK.md
@.planning/research/PITFALLS.md
@.planning/phases/15-objc2-migration/15-01-SUMMARY.md
@.planning/phases/15-objc2-migration/15-02-SUMMARY.md
@overlay/src/platform/macos.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace cocoa imports with objc2-app-kit</name>
  <files>overlay/src/platform/macos.rs</files>
  <action>
Remove all cocoa imports and replace with objc2-app-kit equivalents. Update the imports section:

```rust
//! macOS platform implementation for overlay windows
//!
//! Uses objc2-app-kit for transparent, always-on-top overlay windows
//! with click-through support.

use std::cell::Cell;
use std::ffi::c_void;

// objc2 core
use objc2::rc::Retained;
use objc2::{class, define_class, msg_send, sel, DeclaredClass};

// objc2-foundation types
use objc2_foundation::{NSArray, NSPoint, NSRect, NSSize, NSString};

// objc2-app-kit types
use objc2_app_kit::{
    NSApplication, NSApplicationActivationPolicy, NSBackingStoreType, NSColor, NSEvent,
    NSEventMask, NSEventType, NSScreen, NSView, NSWindow, NSWindowCollectionBehavior,
    NSWindowLevel, NSWindowStyleMask,
};

// Keep core-graphics for CGContext operations
use core_graphics::base::kCGImageAlphaPremultipliedFirst;
use core_graphics::color_space::CGColorSpace;
use core_graphics::context::CGContext;

use super::{MonitorInfo, OverlayConfig, OverlayPlatform, PlatformError};
use super::{MAX_OVERLAY_HEIGHT, MAX_OVERLAY_WIDTH, MIN_OVERLAY_SIZE, RESIZE_CORNER_SIZE};
```

Remove these old imports entirely:
- `use cocoa::appkit::*`
- `use cocoa::base::{id, nil, NO, YES}`
- `use cocoa::foundation::*`
- `use objc::declare::ClassDecl`
- `use objc::runtime::{Class, Object, Sel, BOOL}`
  </action>
  <verify>
List imports in the file - should only have objc2 and core-graphics, no cocoa/objc.
  </verify>
  <done>
Imports section contains only objc2, objc2-foundation, objc2-app-kit, and core-graphics.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update MacOSOverlay struct to use Retained types</name>
  <files>overlay/src/platform/macos.rs</files>
  <action>
Update the MacOSOverlay struct to use Retained<T> instead of raw id pointers:

```rust
pub struct MacOSOverlay {
    window: Retained<NSWindow>,          // Changed from id
    view: Retained<BarasOverlayView>,    // Already changed in Plan 15-02
    width: u32,
    height: u32,
    x: i32,
    y: i32,
    pixel_data: Vec<u8>,
    bgra_buffer: Vec<u8>,

    // Interaction state
    click_through: bool,
    drag_enabled: bool,
    is_dragging: bool,
    is_resizing: bool,
    in_resize_corner: bool,
    position_dirty: bool,
    pending_click: Option<(f32, f32)>,

    // Drag tracking
    drag_start_x: f64,
    drag_start_y: f64,
    drag_start_win_x: i32,
    drag_start_win_y: i32,

    // Resize tracking
    resize_start_x: f64,
    resize_start_y: f64,
    pending_width: u32,
    pending_height: u32,

    running: bool,
    main_screen_height: f64,
}
```

This change satisfies MAC-05: All Objective-C objects use Retained<T> smart pointers.
  </action>
  <verify>
Struct definition shows Retained<NSWindow> and Retained<BarasOverlayView>.
  </verify>
  <done>
MacOSOverlay struct uses Retained<T> for all Objective-C object fields.
  </done>
</task>

<task type="auto">
  <name>Task 3: Migrate MacOSOverlay::new() to objc2-app-kit</name>
  <files>overlay/src/platform/macos.rs</files>
  <action>
Rewrite the `new()` constructor to use objc2-app-kit types:

```rust
impl OverlayPlatform for MacOSOverlay {
    fn new(config: OverlayConfig) -> Result<Self, PlatformError> {
        // objc2-app-kit operations require running on the main thread
        // For overlay use cases, we're always on the main thread during init

        unsafe {
            // Initialize app if needed - use objc2-app-kit
            let app = NSApplication::sharedApplication();
            app.setActivationPolicy(NSApplicationActivationPolicy::Accessory);

            // Get main screen height for coordinate conversion
            let main_screen = NSScreen::mainScreen()
                .ok_or_else(|| PlatformError::Other("No main screen".into()))?;
            let main_frame = main_screen.frame();
            let main_screen_height = main_frame.size.height;

            // Convert position from top-left to bottom-left origin
            let macos_y = main_screen_height - config.y as f64 - config.height as f64;

            let rect = NSRect::new(
                NSPoint::new(config.x as f64, macos_y),
                NSSize::new(config.width as f64, config.height as f64),
            );

            // Create borderless window using objc2-app-kit
            let window: Retained<NSWindow> = {
                let alloc = NSWindow::alloc();
                NSWindow::initWithContentRect_styleMask_backing_defer(
                    alloc,
                    rect,
                    NSWindowStyleMask::Borderless,
                    NSBackingStoreType::Buffered,
                    false,
                )
            };

            // CRITICAL: Prevent window from being released when closed (MAC-04)
            // This is required for correct memory management when not using a window controller
            window.setReleasedWhenClosed(false);

            // Configure window for overlay behavior
            // NSMainMenuWindowLevel (24) + 1 = 25
            window.setLevel(NSWindowLevel(25));
            window.setBackgroundColor(Some(&NSColor::clearColor()));
            window.setOpaque(false);
            window.setHasShadow(false);
            window.setIgnoresMouseEvents(config.click_through);

            // Prevent window from being hidden when app is deactivated
            window.setCollectionBehavior(
                NSWindowCollectionBehavior::CanJoinAllSpaces
                    | NSWindowCollectionBehavior::Stationary
                    | NSWindowCollectionBehavior::IgnoresCycle,
            );

            // Create custom view using our define_class! defined view
            let view = BarasOverlayView::new(rect);

            // Set view as window's content
            window.setContentView(Some(&view));
            window.makeKeyAndOrderFront(None);

            let size = (config.width * config.height * 4) as usize;
            let mut overlay = MacOSOverlay {
                window,
                view,
                width: config.width,
                height: config.height,
                x: config.x,
                y: config.y,
                pixel_data: vec![0u8; size],
                bgra_buffer: vec![0u8; size],
                click_through: config.click_through,
                drag_enabled: true,
                is_dragging: false,
                is_resizing: false,
                in_resize_corner: false,
                position_dirty: false,
                pending_click: None,
                drag_start_x: 0.0,
                drag_start_y: 0.0,
                drag_start_win_x: config.x,
                drag_start_win_y: config.y,
                resize_start_x: 0.0,
                resize_start_y: 0.0,
                pending_width: config.width,
                pending_height: config.height,
                running: true,
                main_screen_height,
            };

            overlay.update_view_buffer();

            Ok(overlay)
        }
    }
    // ... rest of impl
}
```

Key changes:
1. `NSApp()` -> `NSApplication::sharedApplication()`
2. `NSApplicationActivationPolicyAccessory` -> `NSApplicationActivationPolicy::Accessory`
3. `NSScreen::mainScreen(nil)` -> `NSScreen::mainScreen()` (returns Option)
4. `NSWindow::alloc(nil).initWithContentRect_...` -> `NSWindow::initWithContentRect_styleMask_backing_defer(NSWindow::alloc(), ...)`
5. Added `window.setReleasedWhenClosed(false)` for MAC-04
6. `NSWindowStyleMask::NSBorderlessWindowMask` -> `NSWindowStyleMask::Borderless`
7. `NSBackingStoreBuffered` -> `NSBackingStoreType::Buffered`
8. `NSColor::clearColor(nil)` -> `NSColor::clearColor()`
9. `window.setContentView_(view)` -> `window.setContentView(Some(&view))`
10. `window.makeKeyAndOrderFront_(nil)` -> `window.makeKeyAndOrderFront(None)`
  </action>
  <verify>
Run `cargo check -p baras-overlay --target aarch64-apple-darwin`.
  </verify>
  <done>
MacOSOverlay::new() uses objc2-app-kit APIs and includes setReleasedWhenClosed(false).
  </done>
</task>

<task type="auto">
  <name>Task 4: Migrate remaining methods to objc2-app-kit</name>
  <files>overlay/src/platform/macos.rs</files>
  <action>
Update all remaining methods in MacOSOverlay to use objc2-app-kit:

**set_position():**
```rust
fn set_position(&mut self, x: i32, y: i32) {
    let monitors = self.get_monitors();
    let (cx, cy) = super::clamp_to_virtual_screen(x, y, self.width, self.height, &monitors);

    if cx == self.x && cy == self.y {
        return;
    }

    self.x = cx;
    self.y = cy;
    self.position_dirty = true;

    let macos_y = self.convert_y(cy, self.height);
    let point = NSPoint::new(cx as f64, macos_y);
    self.window.setFrameOrigin(point);
}
```

**set_size():**
```rust
fn set_size(&mut self, width: u32, height: u32) {
    if width == self.width && height == self.height {
        return;
    }

    self.width = width;
    self.height = height;
    self.pending_width = width;
    self.pending_height = height;

    let size = (width * height * 4) as usize;
    self.pixel_data.resize(size, 0);
    self.bgra_buffer.resize(size, 0);

    let macos_y = self.convert_y(self.y, height);
    let rect = NSRect::new(
        NSPoint::new(self.x as f64, macos_y),
        NSSize::new(width as f64, height as f64),
    );
    self.window.setFrame_display(rect, true);

    // Update view frame
    let view_rect = NSRect::new(
        NSPoint::new(0.0, 0.0),
        NSSize::new(width as f64, height as f64),
    );
    self.view.setFrame(view_rect);

    self.update_view_buffer();
}
```

**set_click_through():**
```rust
fn set_click_through(&mut self, enabled: bool) {
    self.click_through = enabled;
    self.window.setIgnoresMouseEvents(enabled);

    if enabled {
        self.is_dragging = false;
        self.is_resizing = false;
        self.in_resize_corner = false;
    }
}
```

**commit():**
```rust
fn commit(&mut self) {
    // Convert RGBA to BGRA (Core Graphics expects BGRA with premultiplied alpha)
    for (i, chunk) in self.pixel_data.chunks(4).enumerate() {
        let offset = i * 4;
        if chunk.len() == 4 && offset + 3 < self.bgra_buffer.len() {
            let a = chunk[3] as u32;
            self.bgra_buffer[offset] = ((chunk[2] as u32 * a) / 255) as u8;
            self.bgra_buffer[offset + 1] = ((chunk[1] as u32 * a) / 255) as u8;
            self.bgra_buffer[offset + 2] = ((chunk[0] as u32 * a) / 255) as u8;
            self.bgra_buffer[offset + 3] = chunk[3];
        }
    }

    self.view.setNeedsDisplay(true);
}
```

**poll_events() - most complex migration:**
```rust
fn poll_events(&mut self) -> bool {
    unsafe {
        let app = NSApplication::sharedApplication();

        loop {
            // Create run loop mode string
            let mode = NSString::from_str("kCFRunLoopDefaultMode");

            let event = app.nextEventMatchingMask_untilDate_inMode_dequeue(
                NSEventMask::Any,
                None,  // No timeout - non-blocking
                &mode,
                true,
            );

            let Some(event) = event else {
                break;
            };

            let event_type = event.r#type();

            // Handle events for our window when interactive
            if !self.click_through {
                if let Some(event_window) = event.window() {
                    // Compare window identity
                    if std::ptr::eq(
                        event_window.as_ref() as *const NSWindow,
                        self.window.as_ref() as *const NSWindow,
                    ) {
                        match event_type {
                            NSEventType::LeftMouseDown => {
                                let loc = event.locationInWindow();
                                let x = loc.x;
                                let y = self.height as f64 - loc.y;

                                if self.drag_enabled {
                                    if self.is_in_resize_corner(x, y) {
                                        self.is_resizing = true;
                                        self.pending_width = self.width;
                                        self.pending_height = self.height;
                                        self.resize_start_x = loc.x;
                                        self.resize_start_y = loc.y;
                                    } else {
                                        self.is_dragging = true;
                                        let mouse_loc = NSEvent::mouseLocation();
                                        self.drag_start_x = mouse_loc.x;
                                        self.drag_start_y = mouse_loc.y;
                                        self.drag_start_win_x = self.x;
                                        self.drag_start_win_y = self.y;
                                    }
                                } else {
                                    self.pending_click = Some((x as f32, y as f32));
                                }
                            }
                            NSEventType::LeftMouseUp => {
                                self.is_dragging = false;
                                self.is_resizing = false;
                            }
                            NSEventType::MouseMoved | NSEventType::LeftMouseDragged => {
                                let loc = event.locationInWindow();
                                let x = loc.x;
                                let y = self.height as f64 - loc.y;

                                if !self.is_resizing {
                                    self.in_resize_corner = self.is_in_resize_corner(x, y);
                                }

                                if self.is_dragging {
                                    let mouse_loc = NSEvent::mouseLocation();
                                    let dx = mouse_loc.x - self.drag_start_x;
                                    let dy = self.drag_start_y - mouse_loc.y;
                                    self.set_position(
                                        self.drag_start_win_x + dx as i32,
                                        self.drag_start_win_y + dy as i32,
                                    );
                                } else if self.is_resizing {
                                    let dx = loc.x - self.resize_start_x;
                                    let dy = self.resize_start_y - loc.y;

                                    let new_w = (self.pending_width as i32 + dx as i32)
                                        .clamp(MIN_OVERLAY_SIZE as i32, MAX_OVERLAY_WIDTH as i32)
                                        as u32;
                                    let new_h = (self.pending_height as i32 + dy as i32)
                                        .clamp(MIN_OVERLAY_SIZE as i32, MAX_OVERLAY_HEIGHT as i32)
                                        as u32;

                                    if new_w != self.width || new_h != self.height {
                                        self.set_size(new_w, new_h);
                                        self.resize_start_x = loc.x;
                                        self.resize_start_y = loc.y;
                                    }
                                }
                            }
                            NSEventType::MouseExited => {
                                if !self.is_resizing {
                                    self.in_resize_corner = false;
                                }
                            }
                            _ => {}
                        }
                    }
                }
            }

            // Forward event to app
            app.sendEvent(&event);
        }
    }
    self.running
}
```

**get_monitors() and get_all_monitors():**
```rust
pub fn get_all_monitors() -> Vec<MonitorInfo> {
    let screens = NSScreen::screens();
    let Some(main_screen) = NSScreen::mainScreen() else {
        return Vec::new();
    };
    let main_frame = main_screen.frame();

    screens
        .iter()
        .enumerate()
        .map(|(i, screen)| {
            let frame = screen.frame();
            let name = screen
                .localizedName()
                .map(|s| s.to_string())
                .unwrap_or_else(|| format!("Display {}", i + 1));

            // macOS origin is bottom-left, convert to top-left
            let y = main_frame.size.height - frame.origin.y - frame.size.height;

            MonitorInfo {
                id: format!("screen-{}", i),
                name,
                x: frame.origin.x as i32,
                y: y as i32,
                width: frame.size.width as u32,
                height: frame.size.height as u32,
                is_primary: i == 0,
            }
        })
        .collect()
}
```

Remove the old `nsstring_to_string` helper function - objc2's NSString has proper ToString impl.

**Drop implementation:**
```rust
impl Drop for MacOSOverlay {
    fn drop(&mut self) {
        self.window.close();
    }
}
```
  </action>
  <verify>
Run `cargo check -p baras-overlay --target aarch64-apple-darwin` to verify all methods compile.
  </verify>
  <done>
All MacOSOverlay methods use objc2-app-kit APIs without any cocoa crate usage.
  </done>
</task>

</tasks>

<verification>
1. `cargo check -p baras-overlay --target aarch64-apple-darwin` passes
2. No `cocoa::` or `objc::` imports remain in macos.rs
3. No raw `id` type used (except in draw_rect for CGContext which uses core-graphics)
4. All Objective-C objects use Retained<T>
5. `setReleasedWhenClosed(false)` present in window creation
6. Event types use NSEventType:: prefix (no NS prefix on variants)
7. NSApplication::sharedApplication() used instead of NSApp()
</verification>

<success_criteria>
- All cocoa imports replaced with objc2-app-kit
- MacOSOverlay uses Retained<NSWindow>
- Window creation includes setReleasedWhenClosed(false)
- poll_events uses objc2-app-kit event handling
- get_all_monitors uses objc2-app-kit NSScreen
- Code compiles for macOS target
- Requirements MAC-02, MAC-04, MAC-05 fully satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/15-objc2-migration/15-03-SUMMARY.md`
</output>
