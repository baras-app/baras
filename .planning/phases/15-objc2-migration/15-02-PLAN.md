---
phase: 15-objc2-migration
plan: 02
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - overlay/src/platform/macos.rs
autonomous: true

must_haves:
  truths:
    - "BarasOverlayView uses define_class! macro instead of ClassDecl"
    - "Instance variables use Cell<T> for interior mutability"
    - "drawRect: and isOpaque methods defined with #[unsafe(method(...))] attributes"
    - "View initialization uses set_ivars() pattern"
    - "NSRect parameter works in define_class! methods (implements Encode trait)"
  artifacts:
    - path: "overlay/src/platform/macos.rs"
      provides: "BarasOverlayView defined via define_class!"
      contains: "define_class!"
  key_links:
    - from: "BarasOverlayView"
      to: "NSView"
      via: "#[unsafe(super(NSView))]"
      pattern: "super.*NSView"
    - from: "draw_rect method"
      to: "CGContext drawing"
      via: "ivars().pixel_data.get()"
      pattern: "ivars\\(\\)\\.pixel_data"
    - from: "NSGraphicsContext::currentContext"
      to: "core_graphics::context::CGContext"
      via: "CGContext::from_existing_context_ptr on NSGraphicsContext.CGContext"
      pattern: "from_existing_context_ptr"
---

<objective>
Migrate BarasOverlayView from ClassDecl to define_class! macro.

Purpose: Replace unsafe manual class declaration with objc2's safer, declarative macro. This improves type safety for instance variables and method definitions.

Output: BarasOverlayView defined using define_class! with proper ivars struct and method attributes.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/STACK.md
@.planning/research/PITFALLS.md
@.planning/phases/15-objc2-migration/15-01-SUMMARY.md
@overlay/src/platform/macos.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define BarasOverlayViewIvars struct</name>
  <files>overlay/src/platform/macos.rs</files>
  <action>
Add imports needed for define_class! and the ivars struct. Place this after the existing imports:

```rust
use std::cell::Cell;
use objc2::rc::Retained;
use objc2::{define_class, DeclaredClass, MainThreadMarker};
use objc2_app_kit::{NSGraphicsContext, NSView};
```

Then replace the current static mut OVERLAY_VIEW_CLASS pattern (lines ~80-164) with the define_class! macro. First, define the ivars struct:

```rust
// ─────────────────────────────────────────────────────────────────────────────
// Custom NSView for rendering
// ─────────────────────────────────────────────────────────────────────────────

/// Instance variables for BarasOverlayView.
/// Uses Cell<T> for interior mutability since objc2 methods take &self.
#[derive(Default)]
struct BarasOverlayViewIvars {
    pixel_data: Cell<*mut c_void>,
    buffer_width: Cell<u32>,
    buffer_height: Cell<u32>,
}

// Safety: BarasOverlayView is only used on the main thread (AppKit requirement)
// and pixel_data pointer is only accessed during drawRect: which is single-threaded.
unsafe impl Send for BarasOverlayViewIvars {}
unsafe impl Sync for BarasOverlayViewIvars {}
```

Note: The Send/Sync impls are required because Cell is not Send/Sync, but we know the view is only used on the main thread. The raw pointer to pixel data is stable because it points to MacOSOverlay's bgra_buffer which lives for the lifetime of the overlay.
  </action>
  <verify>
Code compiles without errors after adding the struct.
  </verify>
  <done>
BarasOverlayViewIvars struct defined with Cell-wrapped fields and required trait impls.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement BarasOverlayView with define_class!</name>
  <files>overlay/src/platform/macos.rs</files>
  <action>
Replace the entire get_overlay_view_class() function and related code with define_class!.

**IMPORTANT - NSRect parameter validation:**
NSRect (from objc2_foundation) implements the `Encode` trait, which is required for use as a method parameter in define_class!. This is validated by objc2 at compile time. The NSRect type is specifically designed for Objective-C interop and its Encode implementation matches Apple's type encoding for CGRect/NSRect. No runtime validation needed - if it compiles, it works.

**IMPORTANT - Thread safety:**
Per PITFALLS.md Pitfall 9, add `#[thread_kind = MainThreadOnly]` to enforce main thread access for AppKit views.

**IMPORTANT - No id/nil types:**
Do NOT use cocoa::base::{id, nil} - these are removed in Plan 15-01. Instead:
- Use `Option<Retained<NSGraphicsContext>>` instead of raw `id` with nil checks
- Use `NSGraphicsContext::currentContext()` which returns `Option<Retained<NSGraphicsContext>>`

```rust
define_class!(
    // SAFETY: NSView permits subclassing for custom drawing.
    // We override drawRect: and isOpaque, both of which are designed to be overridden.
    // We do not implement Drop - cleanup happens via Objective-C mechanisms.
    #[unsafe(super(NSView))]
    #[thread_kind = MainThreadOnly]
    #[name = "BarasOverlayView"]
    #[ivars = BarasOverlayViewIvars]
    pub struct BarasOverlayView;

    impl BarasOverlayView {
        /// Draw the overlay content from the pixel buffer.
        /// NSRect implements Encode trait - validated at compile time by objc2.
        #[unsafe(method(drawRect:))]
        fn draw_rect(&self, _dirty_rect: NSRect) {
            let ivars = self.ivars();
            let pixel_ptr = ivars.pixel_data.get();
            let width = ivars.buffer_width.get();
            let height = ivars.buffer_height.get();

            if pixel_ptr.is_null() || width == 0 || height == 0 {
                return;
            }

            unsafe {
                let bounds: NSRect = msg_send![self, bounds];
                let color_space = CGColorSpace::create_device_rgb();

                // Create CGContext from our pixel buffer (BGRA format)
                let ctx = CGContext::create_bitmap_context(
                    Some(pixel_ptr),
                    width as usize,
                    height as usize,
                    8,
                    (width * 4) as usize,
                    &color_space,
                    kCGImageAlphaPremultipliedFirst,
                );

                // create_image returns Option<CGImage>
                if let Some(image) = ctx.create_image() {
                    // Get current graphics context using objc2-app-kit
                    // NSGraphicsContext::currentContext() returns Option<Retained<NSGraphicsContext>>
                    if let Some(ns_ctx) = NSGraphicsContext::currentContext() {
                        // Bridge to core-graphics CGContext:
                        // NSGraphicsContext.CGContext returns the underlying CGContextRef
                        // We use msg_send! to get the raw pointer, then wrap with core-graphics
                        let cg_ctx_ptr: *mut c_void = msg_send![&*ns_ctx, CGContext];

                        if !cg_ctx_ptr.is_null() {
                            // core-graphics CGContext wraps the raw CGContextRef
                            let cg_ctx = CGContext::from_existing_context_ptr(
                                cg_ctx_ptr as *mut core_graphics::sys::CGContext,
                            );

                            cg_ctx.draw_image(
                                core_graphics::geometry::CGRect::new(
                                    &core_graphics::geometry::CGPoint::new(0.0, 0.0),
                                    &core_graphics::geometry::CGSize::new(
                                        bounds.size.width,
                                        bounds.size.height,
                                    ),
                                ),
                                &image,
                            );
                        }
                    }
                }
            }
        }

        /// Report that the view is not opaque to enable transparency.
        #[unsafe(method(isOpaque))]
        fn is_opaque(&self) -> bool {
            false
        }
    }
);

impl BarasOverlayView {
    /// Create a new BarasOverlayView with the given frame.
    fn new(frame: NSRect) -> Retained<Self> {
        let this = Self::alloc();
        let ivars = BarasOverlayViewIvars::default();
        // SAFETY: Calling NSView's initWithFrame: designated initializer
        unsafe { msg_send![super(this.set_ivars(ivars)), initWithFrame: frame] }
    }

    /// Update the pixel buffer pointer and dimensions.
    fn set_pixel_data(&self, data: *mut c_void, width: u32, height: u32) {
        let ivars = self.ivars();
        ivars.pixel_data.set(data);
        ivars.buffer_width.set(width);
        ivars.buffer_height.set(height);
    }
}
```

Delete the old code:
- Remove `static mut OVERLAY_VIEW_CLASS: Option<&'static Class> = None;`
- Remove the entire `fn get_overlay_view_class() -> &'static Class` function
- Remove the `extern "C" fn draw_rect(...)` function
- Remove the `extern "C" fn is_opaque(...)` function
  </action>
  <verify>
Run `cargo check -p baras-overlay --target aarch64-apple-darwin` to verify:
1. The define_class! macro compiles correctly
2. NSRect parameter accepted (Encode trait satisfied)
3. No id/nil references (use Option<Retained<T>> pattern)
  </verify>
  <done>
BarasOverlayView defined with define_class! macro, with:
- #[thread_kind = MainThreadOnly] for thread safety
- drawRect: accepting NSRect parameter (Encode validated at compile time)
- isOpaque returning bool
- No cocoa::base::{id, nil} usage - uses Option<Retained<NSGraphicsContext>> instead
  </done>
</task>

<task type="auto">
  <name>Task 3: Update MacOSOverlay to use new BarasOverlayView</name>
  <files>overlay/src/platform/macos.rs</files>
  <action>
Update the MacOSOverlay struct and its methods to use the new BarasOverlayView type:

1. Change the `view` field type from `id` to `Retained<BarasOverlayView>`:

```rust
pub struct MacOSOverlay {
    window: id,
    view: Retained<BarasOverlayView>,  // Changed from id
    // ... rest unchanged
}
```

2. Update the `new()` constructor (in `impl OverlayPlatform for MacOSOverlay`):

Replace the view creation code:
```rust
// OLD:
let view_class = get_overlay_view_class();
let view: id = msg_send![view_class, alloc];
let view: id = msg_send![view, initWithFrame: rect];
if view == nil {
    return Err(PlatformError::Other("Failed to create NSView".into()));
}

// NEW:
let view = BarasOverlayView::new(rect);
```

3. Update `update_view_buffer()` method to use the new API:

```rust
fn update_view_buffer(&mut self) {
    self.view.set_pixel_data(
        self.bgra_buffer.as_mut_ptr() as *mut c_void,
        self.width,
        self.height,
    );
}
```

4. Update `set_size()` method - the setFrame: msg_send! now needs to reference the view differently:

```rust
// In set_size(), update the view frame line:
let _: () = msg_send![&*self.view, setFrame: view_rect];
```

5. Update `commit()` method:

```rust
// In commit(), update setNeedsDisplay:
let _: () = msg_send![&*self.view, setNeedsDisplay: true];
```

6. Update `window.setContentView_()` call to use the new view type:

```rust
// In new(), after creating the view:
window.setContentView_(self.view.as_ref() as *const _ as id);
// OR use msg_send!:
let _: () = msg_send![window, setContentView: &*view];
```

Note: The `&*self.view` pattern dereferences the `Retained<BarasOverlayView>` to get `&BarasOverlayView`, which can be used in msg_send!.
  </action>
  <verify>
Run `cargo check -p baras-overlay --target aarch64-apple-darwin` to verify all usages compile correctly.
  </verify>
  <done>
MacOSOverlay uses Retained<BarasOverlayView> and all view operations use the new type-safe API.
  </done>
</task>

</tasks>

<verification>
1. `cargo check -p baras-overlay --target aarch64-apple-darwin` passes
2. No `static mut OVERLAY_VIEW_CLASS` remains in the code
3. No `ClassDecl` usage remains (for the view class)
4. BarasOverlayView uses define_class! macro with #[thread_kind = MainThreadOnly]
5. Instance variables accessed via `self.ivars().field.get()/set()`
6. MacOSOverlay.view is `Retained<BarasOverlayView>`
7. No cocoa::base::{id, nil} used in draw_rect - uses Option<Retained<NSGraphicsContext>>
8. NSRect parameter compiles (proves Encode trait implementation)
</verification>

<success_criteria>
- BarasOverlayView defined using define_class! macro with thread safety marker
- Instance variables use Cell<T> pattern
- drawRect: accepts NSRect parameter (Encode validated at compile time)
- draw_rect uses Option<Retained<NSGraphicsContext>> not id/nil
- isOpaque properly defined with method attributes
- MacOSOverlay updated to use Retained<BarasOverlayView>
- Code compiles for macOS target
- Requirements MAC-03 satisfied, MAC-05 partially satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/15-objc2-migration/15-02-SUMMARY.md`
</output>
