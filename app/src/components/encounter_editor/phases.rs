//! Phase editing tab
//!
//! CRUD for boss phase definitions.
//! Uses PhaseDefinition DSL type directly.

use dioxus::prelude::*;

use crate::api;
use crate::types::{BossWithPath, EncounterItem, PhaseDefinition, Trigger};

use super::conditions::CounterConditionEditor;
use super::tabs::EncounterData;
use super::triggers::ComposableTriggerEditor;
use super::InlineNameCreator;

/// Generate a preview of the ID that will be created (mirrors backend logic)
fn preview_id(boss_id: &str, name: &str) -> String {
    let name_part: String = name
        .to_lowercase()
        .chars()
        .map(|c| if c.is_alphanumeric() { c } else { '_' })
        .collect::<String>()
        .split('_')
        .filter(|s| !s.is_empty())
        .collect::<Vec<_>>()
        .join("_");
    format!("{}_{}", boss_id, name_part)
}

// ─────────────────────────────────────────────────────────────────────────────
// Phases Tab
// ─────────────────────────────────────────────────────────────────────────────

/// Create a default phase definition
fn default_phase(name: String) -> PhaseDefinition {
    PhaseDefinition {
        id: String::new(), // Generated by backend
        name,
        display_text: None,
        start_trigger: Trigger::CombatStart,
        end_trigger: None,
        preceded_by: None,
        counter_condition: None,
        resets_counters: vec![],
    }
}

#[component]
pub fn PhasesTab(
    boss_with_path: BossWithPath,
    encounter_data: EncounterData,
    on_change: EventHandler<Vec<PhaseDefinition>>,
    on_status: EventHandler<(String, bool)>,
) -> Element {
    let mut expanded_phase = use_signal(|| None::<String>);

    // Extract phases from BossWithPath
    let phases = boss_with_path.boss.phases.clone();

    rsx! {
        div { class: "phases-tab",
            // Header
            div { class: "flex items-center justify-between mb-sm",
                span { class: "text-sm text-secondary", "{phases.len()} phases" }
                {
                    let bwp = boss_with_path.clone();
                    let phases_for_create = phases.clone();
                    rsx! {
                        InlineNameCreator {
                            button_label: "+ New Phase",
                            placeholder: "Phase name...",
                            on_create: move |name: String| {
                                let phases_clone = phases_for_create.clone();
                                let boss_id = bwp.boss.id.clone();
                                let file_path = bwp.file_path.clone();
                                let phase = default_phase(name);
                                let item = EncounterItem::Phase(phase);
                                spawn(async move {
                                    match api::create_encounter_item(&boss_id, &file_path, &item).await {
                                        Ok(EncounterItem::Phase(created)) => {
                                            let created_id = created.id.clone();
                                            let mut current = phases_clone;
                                            current.push(created);
                                            on_change.call(current);
                                            expanded_phase.set(Some(created_id));
                                            on_status.call(("Created".to_string(), false));
                                        }
                                        Ok(_) => on_status.call(("Unexpected response type".to_string(), true)),
                                        Err(e) => on_status.call((e, true)),
                                    }
                                });
                            }
                        }
                    }
                }
            }

            // Phase list
            if phases.is_empty() {
                div { class: "empty-state text-sm", "No phases defined" }
            } else {
                for phase in phases.clone() {
                    {
                        let phase_key = phase.id.clone();
                        let is_expanded = expanded_phase() == Some(phase_key.clone());
                        let phases_for_row = phases.clone();

                        rsx! {
                            PhaseRow {
                                key: "{phase_key}",
                                phase: phase.clone(),
                                all_phases: phases_for_row,
                                boss_with_path: boss_with_path.clone(),
                                expanded: is_expanded,
                                encounter_data: encounter_data.clone(),
                                on_toggle: move |_| {
                                    expanded_phase.set(if is_expanded { None } else { Some(phase_key.clone()) });
                                },
                                on_change: on_change,
                                on_status: on_status,
                                on_collapse: move |_| expanded_phase.set(None),
                            }
                        }
                    }
                }
            }
        }
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Phase Row
// ─────────────────────────────────────────────────────────────────────────────

#[component]
fn PhaseRow(
    phase: PhaseDefinition,
    all_phases: Vec<PhaseDefinition>,
    boss_with_path: BossWithPath,
    expanded: bool,
    encounter_data: EncounterData,
    on_toggle: EventHandler<()>,
    on_change: EventHandler<Vec<PhaseDefinition>>,
    on_status: EventHandler<(String, bool)>,
    on_collapse: EventHandler<()>,
) -> Element {
    let trigger_label = phase.start_trigger.label();

    rsx! {
        div { class: "list-item",
            // Header row
            div {
                class: "list-item-header",
                onclick: move |_| on_toggle.call(()),
                span { class: "list-item-expand", if expanded { "▼" } else { "▶" } }
                span { class: "font-medium", "{phase.name}" }
                span { class: "text-xs text-mono text-muted", "{phase.id}" }
                span { class: "tag", "{trigger_label}" }
            }

            // Expanded content
            if expanded {
                {
                    let all_phases_for_delete = all_phases.clone();
                    let bwp_for_save = boss_with_path.clone();
                    let bwp_for_delete = boss_with_path.clone();
                    rsx! {
                        div { class: "list-item-body",
                            PhaseEditForm {
                                phase: phase.clone(),
                                all_phases: all_phases,
                                encounter_data: encounter_data,
                                on_save: move |updated: PhaseDefinition| {
                                    on_status.call(("Saving...".to_string(), false));
                                    let boss_id = bwp_for_save.boss.id.clone();
                                    let file_path = bwp_for_save.file_path.clone();
                                    let item = EncounterItem::Phase(updated);
                                    spawn(async move {
                                        match api::update_encounter_item(&boss_id, &file_path, &item, None).await {
                                            Ok(_) => on_status.call(("Saved".to_string(), false)),
                                            Err(_) => on_status.call(("Failed to save".to_string(), true)),
                                        }
                                    });
                                },
                                on_delete: {
                                    let all_phases = all_phases_for_delete.clone();
                                    move |phase_to_delete: PhaseDefinition| {
                                        let all_phases = all_phases.clone();
                                        let boss_id = bwp_for_delete.boss.id.clone();
                                        let file_path = bwp_for_delete.file_path.clone();
                                        spawn(async move {
                                            match api::delete_encounter_item("phase", &phase_to_delete.id, &boss_id, &file_path).await {
                                                Ok(_) => {
                                                    let updated: Vec<_> = all_phases.iter()
                                                        .filter(|p| p.id != phase_to_delete.id)
                                                        .cloned()
                                                        .collect();
                                                    on_change.call(updated);
                                                    on_collapse.call(());
                                                    on_status.call(("Deleted".to_string(), false));
                                                }
                                                Err(err) => {
                                                    on_status.call((err, true));
                                                }
                                            }
                                        });
                                    }
                                },
                            }
                        }
                    }
                }
            }
        }
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Phase Edit Form
// ─────────────────────────────────────────────────────────────────────────────

#[component]
fn PhaseEditForm(
    phase: PhaseDefinition,
    all_phases: Vec<PhaseDefinition>,
    encounter_data: EncounterData,
    on_save: EventHandler<PhaseDefinition>,
    on_delete: EventHandler<PhaseDefinition>,
) -> Element {
    // Clone values needed for closures and display
    let phase_id_display = phase.id.clone();
    let phase_for_delete = phase.clone();

    let mut draft = use_signal(|| phase.clone());
    let original = phase.clone();

    let has_changes = use_memo(move || draft() != original);

    // Get phase IDs for preceded_by dropdown (exclude self)
    let phase_ids: Vec<String> = all_phases
        .iter()
        .filter(|p| p.id != phase.id)
        .map(|p| p.id.clone())
        .collect();

    let handle_save = move |_| {
        let updated = draft();
        on_save.call(updated);
    };

    let handle_delete = move |_| {
        on_delete.call(phase_for_delete.clone());
    };

    rsx! {
        div { class: "phase-edit-form",
            // ─── Identity ────────────────────────────────────────────────────
            div { class: "form-row-hz",
                label { "Phase ID" }
                code { class: "tag-muted text-mono text-xs", "{phase_id_display}" }
            }

            div { class: "form-row-hz",
                label { "Name" }
                input {
                    class: "input-inline",
                    style: "width: 200px;",
                    value: "{draft().name}",
                    oninput: move |e| {
                        let mut d = draft();
                        d.name = e.value();
                        draft.set(d);
                    }
                }
            }

            div { class: "form-row-hz",
                label { "Display Text" }
                input {
                    class: "input-inline",
                    style: "width: 200px;",
                    placeholder: "(defaults to name)",
                    value: "{draft().display_text.clone().unwrap_or_default()}",
                    oninput: move |e| {
                        let mut d = draft();
                        d.display_text = if e.value().is_empty() { None } else { Some(e.value()) };
                        draft.set(d);
                    }
                }
            }

            // ─── Start Trigger ───────────────────────────────────────────────
            div { class: "form-row-hz", style: "align-items: flex-start;",
                label { style: "padding-top: 6px;", "Trigger" }
                ComposableTriggerEditor {
                    trigger: draft().start_trigger,
                    encounter_data: encounter_data.clone(),
                    on_change: move |t| {
                        let mut d = draft();
                        d.start_trigger = t;
                        draft.set(d);
                    }
                }
            }

            // ─── End Trigger (Optional) ──────────────────────────────────────
            div { class: "form-row-hz", style: "align-items: flex-start;",
                label { style: "padding-top: 6px;", "End On" }
                if let Some(end) = draft().end_trigger.clone() {
                    div { class: "flex-col gap-xs",
                        ComposableTriggerEditor {
                            trigger: end,
                            encounter_data: encounter_data.clone(),
                            on_change: move |t| {
                                let mut d = draft();
                                d.end_trigger = Some(t);
                                draft.set(d);
                            }
                        }
                        button {
                            class: "btn btn-sm",
                            style: "width: fit-content;",
                            onclick: move |_| {
                                let mut d = draft();
                                d.end_trigger = None;
                                draft.set(d);
                            },
                            "Remove End Trigger"
                        }
                    }
                } else {
                    div { class: "flex-col gap-xs",
                        span { class: "text-muted text-sm", "(ends when another phase starts)" }
                        button {
                            class: "btn btn-sm",
                            onclick: move |_| {
                                let mut d = draft();
                                d.end_trigger = Some(Trigger::CombatStart);
                                draft.set(d);
                            },
                            "+ Add End Trigger"
                        }
                    }
                }
            }

            // ─── Guards ──────────────────────────────────────────────────────
            div { class: "form-row-hz",
                label { "Preceded By" }
                select {
                    class: "select",
                    style: "width: 180px;",
                    value: "{draft().preceded_by.clone().unwrap_or_default()}",
                    onchange: move |e| {
                        let mut d = draft();
                        d.preceded_by = if e.value().is_empty() { None } else { Some(e.value()) };
                        draft.set(d);
                    },
                    option { value: "", "(none)" }
                    for phase_id in &phase_ids {
                        option { value: "{phase_id}", "{phase_id}" }
                    }
                }
            }

            div { class: "form-row-hz",
                label { "Counter" }
                CounterConditionEditor {
                    condition: draft().counter_condition.clone(),
                    counters: encounter_data.counter_ids(),
                    on_change: move |cond| {
                        let mut d = draft();
                        d.counter_condition = cond;
                        draft.set(d);
                    }
                }
            }

            // ─── Resets Counters ─────────────────────────────────────────────
            div { class: "form-row-hz", style: "align-items: flex-start;",
                label { style: "padding-top: 6px;", "Resets" }
                CounterListEditor {
                    counters: draft().resets_counters.clone(),
                    available_counters: encounter_data.counter_ids(),
                    on_change: move |counters| {
                        let mut d = draft();
                        d.resets_counters = counters;
                        draft.set(d);
                    }
                }
            }

            // ─── Actions ─────────────────────────────────────────────────────
            div { class: "form-actions",
                button {
                    class: if has_changes() { "btn btn-success btn-sm" } else { "btn btn-sm" },
                    disabled: !has_changes(),
                    onclick: handle_save,
                    "Save"
                }
                button {
                    class: "btn btn-danger btn-sm",
                    onclick: handle_delete,
                    "Delete"
                }
            }
        }
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Counter List Editor (for resets_counters)
// ─────────────────────────────────────────────────────────────────────────────

#[component]
fn CounterListEditor(
    counters: Vec<String>,
    available_counters: Vec<String>,
    on_change: EventHandler<Vec<String>>,
) -> Element {
    let mut selected_counter = use_signal(String::new);

    // Filter available counters to exclude already selected ones
    let remaining: Vec<_> = available_counters
        .iter()
        .filter(|c| !counters.contains(c))
        .cloned()
        .collect();

    let counters_for_add = counters.clone();

    rsx! {
        div { class: "flex-col gap-xs",
            // Counter chips
            div { class: "flex flex-wrap gap-xs",
                for (idx, counter) in counters.iter().enumerate() {
                    {
                        let counters_clone = counters.clone();
                        rsx! {
                            span { class: "chip",
                                "{counter}"
                                button {
                                    class: "chip-remove",
                                    onclick: move |_| {
                                        let mut new_counters = counters_clone.clone();
                                        new_counters.remove(idx);
                                        on_change.call(new_counters);
                                    },
                                    "×"
                                }
                            }
                        }
                    }
                }
            }

            // Add from dropdown
            if !remaining.is_empty() {
                div { class: "flex gap-xs",
                    select {
                        class: "select",
                        style: "width: 150px;",
                        value: "{selected_counter}",
                        onchange: move |e| selected_counter.set(e.value()),
                        option { value: "", "Select counter..." }
                        for counter_id in &remaining {
                            option { value: "{counter_id}", "{counter_id}" }
                        }
                    }
                    button {
                        class: "btn btn-sm",
                        disabled: selected_counter().is_empty(),
                        onclick: move |_| {
                            let val = selected_counter();
                            if !val.is_empty() && !counters_for_add.contains(&val) {
                                let mut new_counters = counters_for_add.clone();
                                new_counters.push(val);
                                on_change.call(new_counters);
                                selected_counter.set(String::new());
                            }
                        },
                        "Add"
                    }
                }
            } else if available_counters.is_empty() {
                span { class: "text-xs text-muted", "No counters defined" }
            }
        }
    }
}
